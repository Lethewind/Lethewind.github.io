{"meta":{"title":"Lethe","subtitle":"Farewellswind Blog","description":"Blog to record sth. powered by GitPages & Hexo","author":"Farewellswind","url":"http://lethewind.github.io","root":"/"},"pages":[{"title":"About","date":"2021-09-18T08:20:09.000Z","updated":"2021-09-18T08:21:42.988Z","comments":true,"path":"about/index.html","permalink":"http://lethewind.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-09-18T04:47:39.000Z","updated":"2021-09-18T04:47:55.806Z","comments":true,"path":"categories/index.html","permalink":"http://lethewind.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-18T04:46:33.000Z","updated":"2021-09-18T04:47:01.439Z","comments":true,"path":"tags/index.html","permalink":"http://lethewind.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构笔记（基于浙大MOOC）","slug":"数据结构笔记（基于浙大MOOC）","date":"2021-10-11T05:30:24.000Z","updated":"2021-10-11T05:32:06.368Z","comments":true,"path":"2021/10/11/数据结构笔记（基于浙大MOOC）/","link":"","permalink":"http://lethewind.github.io/2021/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%B5%99%E5%A4%A7MOOC%EF%BC%89/","excerpt":"","text":"数据结构（ZJU-MOOC）第一讲 基本概念1.1 什么是数据结构 数据结构是计算机中存储、组织数据的方式。通常情况下，精心准备的数据结构可以带来最有效率的算法。 通常来说代码的效率与数据的规模直接挂钩，通过将大规模的问题缩小到小规模的问题的方法，往往有奇效。 递归对于空间的占用是极为恐怖的。 时间库&lt;time.h&gt;的使用方法 12345678910111213141516171819202122#include &lt;time.h&gt;#include &lt;stdio.h&gt;clock_t start, stop;/* clock_t 是clock()函数返回的变量类型 */double duration;/* 用来记录运行时间，以秒为单位 */int main()&#123; /* 不在测试范围之前的准备工作写在clock()调用之前 */ start = clock(); //开始计时 MyFunction(); //把测试函数写在这里 stop = clock(); duration = ((double)(stop - start))/CLK_TCK; /* 其他不在测试范围的处理写在后面，例如输出duration的值 */ return 0;&#125; 数据结构是数据对象在计算机中的组织方式，数据对象一定与一系列加在其之上的操作相关联，完成这些操作所用的方法就是算法 线性结构 1 to 1 树形结构 1 to n 图 n to n 抽象数据类型 数据对象集 数据集合相关联的操作集 1.2 什么是算法 算法的定义（一个有限的指令集，输入输出，在有限的步骤后停止，每一条指令都必须有明确的目标且不存在歧义，在计算机处理范围内，描述应不依赖于任何一种计算机语言以及具体的实现手段） 算法的评价指标 空间复杂度$S(n)$ 时间复杂度$O(n)$ 乘除法的时间消耗比加减法高很多，在时间复杂度计算的过程中权重更高 在分析一般算法的效率时，我们经常关注下面两种复杂度 最坏情况复杂度$T_{worst}(n)$ 平均复杂度$T_{avg}(n)$ $T_{avg}(n)\\le T_{worst}(n)$ 复杂度的渐进表示法 1.3 应用实例：最大子列和问题问题描述：给定$N$个整数的序列${A_1,A_2,\\dots,A_N}$,求函数$f(i,j)=max{0,\\sum^j_{k=1}A_k}$的最大值 算法一：暴力搜索，计算出所有子列和，$O(n^3)$ 算法二：利用前缀和，减少一层循环，$O(n^2)$ 算法三：分治思想，分成两段分别寻找最大子列和，然后合并寻找最大子列和，$O(n\\log{n})$ 算法四：在线处理（指每输入一个数据就进行即时处理，在任何一个地方中止输入，算法都能正确给出当前解），$O(N)$ 第二讲 线性结构2.1 线性表及其实现2.1.1 多项式的表示一元多项式$f(x)=a_0+a_1x+\\dots+a_{n-1}x^{n-1}+a_n x^n$及其计算（多项式相加、相减、相乘） 方法一：顺序存储结构直接表示（每一位固定存储对应的指数级的系数） 造成大量浪费，诸如$x+3x^{2000}$ 方法二：顺序存储结构表示非零项（使用结构数组表示，数组分量表示系数和指数，按照指数大小有序存储即可方便计算） 方法三：链表结构存储非零项（链表中每个节点存储多项式的一个非零项，包括系数和指数两个数据域以及一个指针域用于指向下一个节点） 多项式表示问题的启示： 同一个问题可以有不同的表示、存储方式 有一类共性问题：有序线性序列的组织和管理 2.1.2 线性表的实现线性表(Linear List)：由同类型数据元素构成的有序序列的线性结构 表中元素个数称为长度 线性表没有元素时，称为空表 表起始位置称表头，结束位置称表尾 线性表的抽象数据类型描述 主要操作的实现 数组方式 插入 1234for(j=PtrL-&gt;Last;j&gt;=i-1;j--) PtrL-&gt;Data[j+1]=PtrL-&gt;Data[j]; /*将a[i]~a[n]倒序向后移动*/PtrL-&gt;Data[i-1]=X; /*新元素插入*/PtrL-&gt;Last++; /*Last依然指向最后元素*/ 删除 123for(j=i;j&lt;=PtrL-&gt;Last;j++) PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j]; /*将a[i+1]~a[n]顺序向后移动*/PtrL-&gt;Last--; /*Last依然指向最后元素*/ 链表方式 组织形式 1234567typedef struct LNode *List;struct LNode&#123;ElementType Data;List Next;&#125;;struct Lnode L;List PtrL; 求表长（遍历一遍） 123456789int Length(List PtrL)&#123; List p=PtrL; /*p指向表的第一个节点*/ int j=0; while(p)&#123; p=p-&gt;next; j++; /*当前p指向的是第j个节点*/ &#125; return j;&#125; 查找 1234567891011121314151617181920/*按照序号查找*/List FindKth(int K,List PtrL)&#123; List p=PtrL; int i=1; while(p!=NULL&amp;&amp;i&lt;K)&#123; p=p-&gt;next; i++; &#125; if(i==K)return p; /*找到第K个，返回指针*/ else return NULL; /*否则返回空*/&#125;/*按照数据值进行查找*/List Find(List PtrL,ElementType X)&#123; List p=PtrL; /* p指向L的第1个结点 */ while (p!=NULL&amp;&amp;p-&gt;Data!=X) p=p-&gt;Next; /* 下列语句可以用 return p; 替换 */ if(p)return p; else return ERROR;&#125; 插入 先构造一个新节点，用s指向； 再找到链表的第$i-1$个节点，用p指向； 然后修改指针，插入节点（p之后插入新节点s）。 1234567891011121314151617181920List Insert(ElementType X,int i,List PtrL)&#123; List p,s; if(i==1)&#123; /*新节点插入在表头*/ s=(List)malloc(sizeof(struct LNode)); /*申请、装填节点*/ s-&gt;Data=X; s-&gt;Next=PtrL; return s; &#125; p=FindKth(i-1,PtrL); /*查找第i-1个节点*/ if(p==NULL)&#123; /*第i-1个节点不存在*/ return ERROR; &#125;else&#123; s=(List)malloc(sizeof(struct LNode)); s-&gt;Data=X; s-&gt;Next=p-&gt;Next; /*新节点插入在第i-1个节点之后*/ p-&gt;Next=s; return PtrL; &#125; &#125; 删除 先找到链表的第$i-1$个节点，用p指向； 再用指针s指向要被删除的节点（p的下一个节点）； 然后修改指针，删除s所指节点； 最后释放s所指的节点的空间。 123456789101112131415161718192021List Dlete(int i,List PtrL)&#123; List p,s; if(i==1)&#123; s=PtrL; if(PtrL!=NULL)PtrL=PtrL-&gt;Next; else return NULL; free(s); return PtrL; &#125; p=FindKth(i-1,PtrL); if(p==NULL)&#123; printf(&quot;第%d个节点不存在&quot;,i-1);return NULL; &#125;else if(p-&gt;next==NULL)&#123; printf(&quot;第%d个节点不存在&quot;,i);return NULL; &#125;else &#123; s=p-&gt;Next; /*s指向第i个节点*/ p-&gt;Next=s-&gt;Next; /*从链表中删除*/ free(s); /*释放被删除节点空间*/ return PtrL; &#125;&#125; 2.1.3 广义表广义表是线性表的推广，对于线性表来说，n个元素都是基本的单元素，广义表中，这些元素不仅可以是单元素也可以是另一个广义表。 双向链表、多重链表 矩阵尤其是稀疏矩阵，使用多重链表中的十字链表进行存储更有利于节省存储空间 2.2 堆栈2.2.1 什么是堆栈堆栈Stack：具有一定操作约束的线性表，只能在一端（栈顶，top）做插入和删除（先进后出Last In First Out） 插入数据：入栈Push，删除数据：出栈Pop 堆栈的抽象数据类型描述： 2.2.2 堆栈的实现 数组实现 12345678910111213141516171819202122typedef struct SNode *Stack;struct SNode&#123; ElementType Data[MaxSize]; int Top;&#125;;void Push(Stack PtrS,ElementType item)&#123; if(PtrS-&gt;Top==MaxSize-1)&#123; printf(&quot;Full&quot;);return; &#125;else&#123; PtrS-&gt;Data[++(PtrS-&gt;Top)]=item; return; &#125;&#125;ElementType Pop(Stack PtrS)&#123; if(PtrS-&gt;Top==-1)&#123; printf(&quot;Empty&quot;); return ERROR; &#125;else return (PtrS-&gt;Data[(PtrS-&gt;Top)--]);&#125; 链表实现 1234567891011121314151617181920212223242526272829303132333435363738struct SNode&#123; ElementType Data; struct SNode *Next;&#125;;Stack CreateStack()&#123; Stack S; S=(Stack)malloc(sizeof(struct SNode)); S-&gt;Next=NULL; return s;&#125;int IsEmpty(Stack S)&#123; return (S-&gt;Next==NULL);&#125;void Push(ElementType item,Stack S)&#123; struct SNode *TmpCell; TmpCell=(struct SNode *)malloc(sizeof(struct SNode)); TmpCell-&gt;Element=item; TmpCell-&gt;Next=S-&gt;Next; S-&gt;Next=TmpCell;&#125;/*可以看到链表的堆栈是以链表头为栈顶，在此处进行插入和删除实现的*/ElementType Pop(Stack S)&#123; struct SNode *FirstCell; ElementType TopElem; if(IsEmpty(S))&#123; printf(&quot;Empty&quot;);return NULL; &#125;else&#123; FirstCell=S-&gt;Next; S-&gt;Next=FirstCell-&gt;Next; TopElem=FirstCell-&gt;Element; free(FirstCell); return TopElem; &#125;&#125; 2.2.3 表达式求值 中缀表达式：$a+b*c-d/e$ 后缀表达式：$abc*+de/-$ 后缀表达式求值策略：从左向右“扫描”，逐个处理运算数和运算符号；遇到运算数时压栈，遇到运算符号时从堆栈中弹出适当的运算数，计算结构后入栈；最后栈顶元素就是表达式的结果。 中缀表达式转后缀表达式 2.3 队列2.3.1 什么是队列队列Queue：具有一定操作约束的线性表，只能在一端插入，另一端删除，即先进先出。 数据插入：入队列AddQ，数据删除：出队列DeleteQ，先进先出FIFO 队列的抽象数据类型描述 2.3.2 队列的实现 数组实现 1234567891011121314151617181920212223242526272829struct QNode&#123; ElementType Data[MaxSize]; int rear; int front;&#125;;typedef struct QNode *Queue;//思考循环链表判断队列空和满的条件void AddQ(Queue PtrQ,ElementType item)&#123; if(PtrQ-&gt;rear+1==MaxSize)&#123; //(PtrQ-&gt;rear+1)%MaxSize==PtrQ-&gt;front printf(&quot;Full&quot;); return; &#125; //PtrQ-&gt;rear=(PtrQ-&gt;rear+1)%MaxSize; //PtrQ-&gt;Data[PtrQ-&gt;rear]=item; PtrQ-&gt;Data[++PtrQ-&gt;rear]=item;&#125;ElementType DeleteQ(Queue PtrQ)&#123; if(PtrQ-&gt;front==PtrQ-&gt;rear)&#123; printf(&quot;Empty&quot;); return; &#125;else&#123; //PtrQ-&gt;front=(PtrQ-&gt;front+1)%MaxSize; //return PtrQ-&gt;Data[PtrQ-&gt;front]; return PtrQ[PtrQ-&gt;front++]; &#125;&#125; 链表实现 123456789101112131415161718192021222324252627282930struct Node&#123; ElementType Data; struct Node *Next;&#125;;struct QNode&#123; struct Node *rear; struct Node *front;&#125;;typedef struct QNode *Queue;Queue PtrQ;ElementType DeleteQ(Queue PtrQ)&#123; struct Node *FrontCell; ElementType FrontElem; if(PtrQ-&gt;front==NULL)&#123; printf(&quot;Empty&quot;); return ERROR; &#125; FrontCell=PtrQ-&gt;front; if(PtrQ-&gt;front==PtrQ-&gt;rear)//若队列只有一个元素 PtrQ-&gt;front=PtrQ-&gt;rear=NULL;//删除后置队列为空 else PtrQ-&gt;front=PtrQ-&gt;front-&gt;Next; FrontElem=FrontCell-&gt;Data; free(FrontCell);//释放被删除节点空间 return FrontElem;&#125; 第三章 树3.1 树与树的表示3.1.1 查找查找Searching：根据某个给定的关键词K，从集合R中找到关键字与K相同的记录 静态查找：集合中记录是固定的，没有插入和删除操作，只有查找 动态查找：集合中记录是动态变化的；除查找，还可能发生插入和删除 静态查找方法 方法一：顺序查找$O(n)$ 方法二：二分查找$O(log{n})$ 假设n个数据元素的关键字满足有序，如$k_1&lt;k_2&lt;\\cdots&lt;k_n$，并且是连续存放（数组），那么可以进行二分查找 $mid=(left+right)/2$ 123456789101112int BinarySearch(List Tbl,ElementType K)&#123; int left,right,mid,NotFound=-1; left=1; right=Tbl-&gt;Length; while(left&lt;=right)&#123; mid=(left&lt;=right)/2; if(K&lt;Tbl-&gt;Element[mid])right=mid-1; else if(K&gt;Tbl-&gt;Element[mid])left=mid+1; else return mid; &#125; return NotFound;&#125; 3.1.2 树的基础树Tree：$n$个节点构成的有限集合。当$n=0$时，称为空树；对于任一非空树$n&gt;0$，它具备如下特征： 树中有一个称为根Root节点的特殊节点，用r表示； 其余节点可以分为$m(m&gt;0)$个互不相交的有限集$T_1,T_2,\\dots,T_m$，其中每个集合本身又是一棵树，称为原来树的“子树SubTree” 树的一些基本术语 结点的度Degree：结点的子树个数 树的度：树的所有节点中最大的度数 叶结点Leaf：度为0的结点 父结点Parent：有子树的结点是其子树的根结点的父结点 子结点Child：若A结点是B结点的父结点，则称B结点是A结点的子结点 兄弟结点Siblings：具有同一父结点的各结点彼此是兄弟结点 路径和路径长度：从结点$n_1$到结点$n_k$的路径为一个结点序列$n_1,n_2,\\dots,n_k$，$n_i$是$n_{i+1}$的父结点。路径所包含的边的个数为路径的长度。 祖先结点Ancestor：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。 子孙结点Descendant：某一结点的子树中所有结点是这个结点的子孙。 结点的层次Level：规定根结点在1层，其他任一结点的层数是其父结点的层数加1。 树的深度Depth：树中所有结点中最大层次是这棵树的深度 树相关的计算 规律1：（节点个数）m=（边数）n+1规律2： 度为节点的子女个数，可以看作几个出边就是几个度，叶子节点没有度 树的表示 儿子兄弟表示法 实际上此方法就构造了一棵新的二叉树，也即实现了二叉树的表示即可表示任意树。 3.2 二叉树及存储结构3.2.1 二叉树的定义二叉树$T$：一个有穷的结点集合，这个结点可以为空，若不为空，则它是由根结点和称为其左子树$T_L$和右子树$T_R$的两个不相交的二叉树组成。其中每个结点的度最大为2。 二叉树的子树有左右顺序之分 二叉树的五种基本形态 特殊二叉树 斜二叉树Skewed Binary Tree 完全二叉树Complete Binary Tree 有n个结点的二叉树，对树中结点按从上至下、从左到右顺序进行编号，编号为$i (1\\le i \\le n)$结点与满二叉树中编号为i结点在二叉树中位置相同 完美二叉树Perfect Binary Tree、满二叉树Full Binary Tree 3.2.2 二叉树的几个重要性质 一个二叉树第$i$层最大结点数为：$2^{i-1},i\\ge 1$ 深度为$k$的二叉树有最大结点数为：$2^k-1,k\\ge1$ 对任何非空二叉树$T$，若$n_0$表示叶结点的个数、$n_2$是度为2的非叶结点的个数，那么两者的关系满足$n_0=n_2+1$ $n$个结点的二叉树一共多少种？ $f(n)=\\frac{(2n)!}{n!(n+1)!}$ $n$层二叉树的第$n$层最多有多少个结点？ $f(n)=2^{n-1}$ 一个有$n$个结点的完全二叉树的深度为？ $h(n)=log_2n+1$ 一个完全二叉树的结点为$n$，则该二叉树的叶子结点为多少？ $f(n)=n-(n/2)$ 3.2.3 二叉树的表示和实现二叉树的抽象表示 二叉树的存储结构 顺序存储结构 完全二叉树：按从上至下、从左到右顺序存储 $n$个结点的完全二叉树的结点父子关系： 非根结点（序号$i&gt;1$）的父结点的序号是$\\lfloor i \\rfloor$ 结点（序号为$i$）的左孩子结点的序号是$2i$（$2i\\le n$，否则没有左孩子） 结点（序号为$i$）的右孩子结点的序号是$2i+1$（$2i+1\\le n$，否则没有左孩子） 对于一般的二叉树也可以使用这种结构，但会造成很高的空间浪费 链表存储 1234567typedef struct TreeNode *BinTree;typedef BinTree Position;struct TreeNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;; 静态链表 使用结构数组构建“链表形式”的“静态链表”，其中左右孩子指示位存储的是左右孩子所对应的下标 3.3 二叉树的遍历先序、中序、后序遍历过程中经过节点的路线一样，只是访问各结点的实际不同。 3.3.1 先序遍历访问根结点、先序遍历其左子树、先序遍历其右子树 先序遍历非递归遍历算法：使用堆栈 遇到一个结点，就把它输入然后压栈，并去遍历其左子树 当左子树遍历结束后，按照其右指针再去中序遍历该结点的右子树 1234567891011121314151617181920void preOrder2(BinTree *root) //非递归前序遍历&#123; stack&lt;BinTree*&gt; s; BinTree *p=root; while(p!=NULL||!s.empty()) &#123; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; s.push(p); p=p-&gt;lchild; &#125; if(!s.empty()) &#123; p=s.top(); s.pop(); p=p-&gt;rchild; &#125; &#125;&#125; 3.3.2 中序遍历中序遍历其左子树、访问根结点、中序遍历其右子树 中序遍历非递归遍历算法：使用堆栈 遇到一个结点，就把它压栈，并去遍历其左子树 当左子树遍历结束后，从栈顶弹出此结点并访问之 然后按照其右指针再去中序遍历该结点的右子树 1234567891011121314151617181920void inOrder2(BinTree *root) //非递归中序遍历&#123; stack&lt;BinTree*&gt; s; BinTree *p=root; while(p!=NULL||!s.empty()) &#123; while(p!=NULL) &#123; s.push(p); p=p-&gt;lchild; &#125; if(!s.empty()) &#123; p=s.top(); cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; s.pop(); p=p-&gt;rchild; &#125; &#125;&#125; 3.3.3 后序遍历后序遍历其左子树、后序遍历其右子树、访问根节点 后序遍历非递归遍历算法：使用堆栈 第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问， 因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就 保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是 否是第一次出现在栈顶。 123456789101112131415161718192021222324252627282930313233void postOrder2(BinTree *root) //非递归后序遍历&#123; stack&lt;BTNode*&gt; s; BinTree *p=root; BTNode *temp; while(p!=NULL||!s.empty()) &#123; while(p!=NULL) //沿左子树一直往下搜索，直至出现没有左子树的结点 &#123; BTNode *btn=(BTNode *)malloc(sizeof(BTNode)); btn-&gt;btnode=p; btn-&gt;isFirst=true; s.push(btn); p=p-&gt;lchild; &#125; if(!s.empty()) &#123; temp=s.top(); s.pop(); if(temp-&gt;isFirst==true) //表示是第一次出现在栈顶 &#123; temp-&gt;isFirst=false; s.push(temp); p=temp-&gt;btnode-&gt;rchild; //访问其右子树 &#125; else //第二次出现在栈顶 &#123; cout&lt;&lt;temp-&gt;btnode-&gt;data&lt;&lt;&quot; &quot;; p=NULL; &#125; &#125; &#125;&#125; 第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存 在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了 每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。 12345678910111213141516171819202122232425void postOrder3(BinTree *root) //非递归后序遍历&#123; stack&lt;BinTree*&gt; s; BinTree *cur; //当前结点 BinTree *pre=NULL; //前一次访问的结点 s.push(root); while(!s.empty()) &#123; cur=s.top(); if((cur-&gt;lchild==NULL&amp;&amp;cur-&gt;rchild==NULL)|| (pre!=NULL&amp;&amp;(pre==cur-&gt;lchild||pre==cur-&gt;rchild))) &#123; cout&lt;&lt;cur-&gt;data&lt;&lt;&quot; &quot;; //如果当前结点没有孩子结点或者孩子节点都已被访问过 s.pop(); pre=cur; &#125; else &#123; if(cur-&gt;rchild!=NULL) s.push(cur-&gt;rchild); if(cur-&gt;lchild!=NULL) s.push(cur-&gt;lchild); &#125; &#125;&#125; 3.3.4 层次遍历二叉树遍历的核心问题：二维结构的线性化 从结点访问其左、右儿子结点 访问左儿子后，右儿子结点需要一个存储结构（堆栈、队列）保存暂时不访问的结点 层序遍历的实现：利用队列，遍历从根节点开始，首先将根结点入队，然后开始执行循环：结点出队、访问该结点、其左右儿子入队 3.3.5 遍历二叉树算法的应用 输出二叉树中的叶子结点：在二叉树的遍历算法中增加检测结点“左右子树是否都为空”的判断语句。 求二叉树的高度：二叉树的高度为其左子树和右子树高度最大值+1 二元运算表达式树及其遍历 由两种遍历序列确定二叉树（必须要有中序序列） 判别两个二叉树是否同构 3.4 二叉搜索树3.4.1 什么是二叉搜索树组织动态查找时，若将数据按照一定的规则在二叉树中进行存储，则每次的搜索的效率取决于树的深度$h(n)=log_2n+1$，即得到一种高效的算法。 二叉搜索树BST,Binary Search Tree，也称二叉排序树或二叉查找树。为一棵非空二叉树，且满足如下三条性质： 非空左子树的所有键值小于其根结点的键值； 非空右子树的所有键值大于其根结点的键值； 左、右子树都是二叉搜索树。 3.4.2 二叉搜索树的抽象表示和实现二叉搜索树的抽象表示 二叉搜索树的查找操作Find 查找从根结点开始，如果树为空，返回NULL 若搜索树非空，则根结点关键字和X进行比较，并进行不同处理： 若X小于根结点键值，只需要在左子树中继续搜索 若X大于根结点键值，在右子树中进行继续搜索 若两者比较结果相等，搜索完成，返回指向此节点的指针 递归实现 123456789Position Find(ElementType X,BinTree BST)&#123; if(!BST)return NULL; if(X&gt;BST-&gt;Data) return Find(X,BST-&gt;Right); else if(X&lt;BST-&gt;Data) return Find(X,BST-&gt;Left); else return BST;&#125; 非递归（循环）实现 1234567891011Position IterFind(ElementType X,BinTree BST)&#123; while(BST)&#123; if(X&gt;BST-&gt;Data) BST=BST-&gt;Right; else if(X&lt;BST-&gt;Data) BST=BST-&gt;Left; else return BST; &#125; return NULL;&#125; 查找最大和最小元素 最大元素一定在树的最右分枝的端结点上，最小元素一定在树的最左分枝的端结点上 查找最大/小元素实现 12345678910111213Position FindMin(BinTree BST)&#123; if(!BST)return NULL; else if(!BST-&gt;Left) return BST; else return FindMin(BST-&gt;Left);&#125;Position FindMax(BinTree BST)&#123; if(BST) while(BST-&gt;Right)BST=BST-&gt;Right; return BST;&#125; 二叉搜索树的插入 12345678910111213BinTree Insert(ElementType X,BinTree BST)&#123; if(!BST)&#123; //若原树为空，生成并返回一个结点的二叉搜索树 BST=malloc(sizeof(struct TreeNode)); BST-&gt;Data=X; BST-&gt;Left=BST-&gt;Right=NULL; &#125;else if(X&lt;BST-&gt;Data) //递归插入左子树 BST-&gt;Left=Insert(X,BST-&gt;Left); else if(X&gt;BST-&gt;Data) //递归插入右子树 BST-&gt;Right=Insert(X,BST-&gt;Right); //X已经存在，查找到原址 return BST;&#125; 二叉搜索树的删除 考虑三种情况： 要删除的是叶结点：直接删除并修改其父节点指针——置为NULL 要删除的节点只有一个孩子结点：将其父结点的指针指向要删除的结点的孩子结点 要删除的结点有左、右子树：用另一个结点替代被删除节点，通常是左子树的最大元素或右子树的最小元素 12345678910111213141516171819202122232425BinTree Delete(ElementType X,BinTree BST)&#123; Position Tmp; if(!BST)printf(&quot;Unfindable!&quot;); else if(X&lt;BST-&gt;Data) BST-&gt;Left=Delete(X,BST-&gt;Left); //左子树递归删除 else if(X&gt;BST-&gt;Data) BST-&gt;Right=Delete(X,BST-&gt;Right); //右子树递归删除 else if(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123; //找到了被删除节点，且点有左右两个子结点 //在右子树中找到最小元素 Tmp=FindMin(BST-&gt;Right); //将找到的最小值赋值给被删除结点 BST-&gt;Data=Tmp-&gt;Data; BST-&gt;Right=Delete(BST-&gt;Data,BST-&gt;Right); //在删除节点的右子树中删除最小元素 &#125;else&#123; //被删除结点有一个或无子结点 Tmp=BST; if(!BST-&gt;Left) // 有右孩子或无子结点 BST=BST-&gt;Right; else if(!BST-&gt;Right) // 有左孩子或无子结点 BST=BST-&gt;Left; free(Tmp); &#125; return BST;&#125; 3.4.3 判别是否是同一棵二叉搜索树 分别两个输入序列构造两棵二叉搜索树，然后判别是否相同 不建树的判别方法，根据序列，通过定位根节点位置进行判断 建一棵树，再判别其他序列是否与该树一致 搜索树的表示 建搜索树 判别一序列是否与搜索树$T$一致 3.5 平衡二叉树3.5.1 什么是平衡二叉树搜索树结点不同的插入次序，将导致不同的深度和平均查找长度ASL的不同 平衡因子Balance Factor(BF)：$BF(T)=h_L-h_R$，其中$h_L$和$h_R$分别为$T$的左子树和右子树的高度 平衡二叉树Balanced Binary Tree/AVL Tree：空树或者任一结点左右子树高度差的绝对值不超过1，即$|BF(T)|\\le 1$ 3.5.2 平衡二叉树的调整 RR旋转：不平衡的“发现者”是A，“麻烦结点”在发现者右子树的右边，因此成为RR插入，需要RR旋转（右单旋） LL旋转：不平衡的“发现者”是A，“麻烦结点”在发现者左子树的左边，因此称为LL插入，需要LL旋转（左单旋） LR旋转：不平衡的“发现者”是A，“麻烦结点”在左子树的右边，因此叫做LR插入，需要LR旋转 RL旋转：与LR旋转类似 PS：有的时候插入元素即使不需要调整结构，也可能需要重新计算平衡因子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;template&lt;class T&gt;struct Node &#123; T key; Node&lt;T&gt;* lchild; Node&lt;T&gt;* rchild; Node&lt;T&gt;(T k) : key(k), lchild(nullptr), rchild(nullptr) &#123;&#125;&#125;;template&lt;class T&gt;class AVLTree &#123;private: Node&lt;T&gt;* root;public: AVLTree() :root(nullptr) &#123;&#125;; Node&lt;T&gt;* getRoot() &#123; return root; &#125; void printTree(); Node&lt;T&gt;* llRotation(Node&lt;T&gt;*); Node&lt;T&gt;* lrRotation(Node&lt;T&gt;*); Node&lt;T&gt;* rrRotation(Node&lt;T&gt;*); Node&lt;T&gt;* rlRotation(Node&lt;T&gt;*); void balance(Node&lt;T&gt;*); void insert(const T&amp;); bool remove(Node&lt;T&gt;*, Node&lt;T&gt;*, T); int getDepth(Node&lt;T&gt;*); int getBalanceFactor(Node&lt;T&gt;*); Node&lt;T&gt;* findMin(Node&lt;T&gt;*); Node&lt;T&gt;* findMax(Node&lt;T&gt;*); void fixUp(); Node&lt;T&gt;* find(Node&lt;T&gt;* node, T key);&#125;;template&lt;class T&gt;void AVLTree&lt;T&gt;::printTree() &#123; //层次遍历 Node&lt;T&gt;* pos = root; //当前位置 Node&lt;T&gt;* flag = root; //层末标识 queue&lt;Node&lt;T&gt;*&gt; q; q.push(root); //根节点入队 while (!q.empty()) &#123; //队列非空 Node&lt;T&gt;* node = q.front(); q.pop(); //弹出队首 cout &lt;&lt; node-&gt;key &lt;&lt; &#x27;\\t&#x27;; if (node-&gt;lchild != nullptr) &#123; //左孩子非空则入队 q.push(node-&gt;lchild); pos = node-&gt;lchild; &#125; if (node-&gt;rchild != nullptr) &#123; //右孩子非空则入队 q.push(node-&gt;rchild); pos = node-&gt;rchild; &#125; if (node == flag) &#123; //抵达层末 flag = pos; cout &lt;&lt; &quot;\\n&quot;; &#125; &#125;&#125;template&lt;class T&gt;void AVLTree&lt;T&gt;::insert(const T&amp; key) &#123; Node&lt;T&gt;* node = new Node&lt;T&gt;(key); if (root == nullptr) &#123; root = node; return; &#125; Node&lt;T&gt;* pos = root; while (true) &#123; //查找插入位置 if (node-&gt;key &lt; pos-&gt;key) &#123; if (pos-&gt;lchild == nullptr) &#123; pos-&gt;lchild = node; fixUp(); return; &#125; //end if else pos = pos-&gt;lchild; &#125; //end if else if (node-&gt;key &gt; pos-&gt;key) &#123; if (pos-&gt;rchild == nullptr) &#123; pos-&gt;rchild = node; fixUp(); return; &#125; //end if else pos = pos-&gt;rchild; &#125; //end if else return; //树中已有此节点则无操作 &#125; //end while&#125;template&lt;class T&gt;int AVLTree&lt;T&gt;::getDepth(Node&lt;T&gt;* node) &#123; if (node == nullptr) return 0; return max(getDepth(node-&gt;lchild), getDepth(node-&gt;rchild)) + 1;&#125;template&lt;class T&gt;int AVLTree&lt;T&gt;::getBalanceFactor(Node&lt;T&gt;* node) &#123; //平衡因子 = 左子树高-右子树高 return getDepth(node-&gt;lchild) - getDepth(node-&gt;rchild);&#125;template&lt;class T&gt;void AVLTree&lt;T&gt;::balance(Node&lt;T&gt;* node) &#123; int bf = getBalanceFactor(node); if (bf &gt; 1) &#123; if (getBalanceFactor(node-&gt;lchild) &gt; 0) root = llRotation(node); else root = lrRotation(node); &#125; else if (bf &lt; -1) &#123; if (getBalanceFactor(node-&gt;rchild) &gt; 0) root = rlRotation(node); else root = rrRotation(node); &#125; return;&#125;//LLtemplate&lt;class T&gt;Node&lt;T&gt;* AVLTree&lt;T&gt;::llRotation(Node&lt;T&gt;* node) &#123; //插入节点在左子树左边，右旋 Node&lt;T&gt;* temp = node-&gt;lchild; node-&gt;lchild = temp-&gt;rchild; temp-&gt;rchild = node; return temp;&#125;//LRtemplate&lt;class T&gt;Node&lt;T&gt;* AVLTree&lt;T&gt;::lrRotation(Node&lt;T&gt;* node) &#123; //插入节点在左子树右边 Node&lt;T&gt;* temp = node-&gt;lchild; node-&gt;lchild = rrRotation(temp); return llRotation(node);&#125;//RLtemplate&lt;class T&gt;Node&lt;T&gt;* AVLTree&lt;T&gt;::rlRotation(Node&lt;T&gt;* node) &#123; //插入节点在右子树左边 Node&lt;T&gt;* temp = node-&gt;rchild; node-&gt;rchild = llRotation(temp); return rrRotation(node);&#125;//RRtemplate&lt;class T&gt;Node&lt;T&gt;* AVLTree&lt;T&gt;::rrRotation(Node&lt;T&gt;* node) &#123; //插入节点在右子树右边，左旋 Node&lt;T&gt;* temp = node-&gt;rchild; node-&gt;rchild = temp-&gt;lchild; temp-&gt;lchild = node; return temp;&#125;template&lt;class T&gt;bool AVLTree&lt;T&gt;::remove(Node&lt;T&gt;* node, Node&lt;T&gt;* parent, T key) &#123; Node&lt;T&gt;* temp = nullptr; if (node == nullptr) // 未找到目标节点 return false; else if (key &lt; node-&gt;key) return remove(node-&gt;lchild, node, key); else if (key &gt; node-&gt;key) return remove(node-&gt;rchild, node, key); else if (node-&gt;lchild &amp;&amp; node-&gt;rchild) &#123; //删除节点有左子树也有右子树 if (getDepth(node-&gt;lchild) &gt; getDepth(node-&gt;rchild)) &#123; //左子树高，前驱替代 temp = findMax(node-&gt;lchild); node-&gt;key = temp-&gt;key; return remove(node-&gt;lchild,node, node-&gt;key); &#125; else &#123; //右子树不比左子树矮，后驱替代 temp = findMin(node-&gt;rchild); node-&gt;key = temp-&gt;key; return remove(node-&gt;rchild, node, node-&gt;key); &#125; &#125; else &#123; if ((node-&gt;lchild &amp;&amp; node-&gt;rchild == nullptr)) &#123; //删除节点有左孩子无右孩子 temp = findMax(node-&gt;lchild); node-&gt;key = temp-&gt;key; return remove(node-&gt;lchild, node, node-&gt;key); &#125; else if (node-&gt;rchild &amp;&amp; node-&gt;lchild == nullptr) &#123; //删除节点有右孩子无左孩子 temp = findMin(node-&gt;rchild); node-&gt;key = temp-&gt;key; return remove(node-&gt;rchild, node, node-&gt;key); &#125; //end if else &#123; //删除节点最终递归到删除叶子节点 if (node == parent-&gt;lchild) //父节点指针置空 parent-&gt;lchild = nullptr; else parent-&gt;rchild = nullptr; delete node; //释放子节点 node = nullptr; fixUp(); &#125; &#125; //end else return true;&#125;template&lt;class T&gt;void AVLTree&lt;T&gt;::fixUp() &#123; Node&lt;T&gt;* temp = this-&gt;root; //自顶向下调整树 while (1) //寻找失衡的节点 &#123; if (getBalanceFactor(temp) == 2) &#123; if (fabs(getBalanceFactor(temp-&gt;lchild)) == 1) break; else temp = temp-&gt;lchild; &#125; else if (getBalanceFactor(temp) == -2) &#123; if (fabs(getBalanceFactor(temp-&gt;rchild)) == 1) break; else temp = temp-&gt;rchild; &#125; else break; &#125; balance(temp); return;&#125;template&lt;class T&gt;Node&lt;T&gt;* AVLTree&lt;T&gt;::find(Node&lt;T&gt;* node, T key) &#123; while (node != nullptr &amp;&amp; key != node-&gt;key) &#123; //迭代查找 if (key &lt; node-&gt;key) node = node-&gt;lchild; else node = node-&gt;rchild; &#125; if (node == nullptr) cout &lt;&lt; &quot;Element &quot; &lt;&lt; key &lt;&lt; &quot; doesn&#x27;t exist!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Element &quot; &lt;&lt; key &lt;&lt; &quot; exists.&quot; &lt;&lt; endl; return node;&#125;template&lt;class T&gt;Node&lt;T&gt;* AVLTree&lt;T&gt;::findMax(Node&lt;T&gt;* node) &#123; if (node != nullptr) &#123; while (node-&gt;rchild) node = node-&gt;rchild; &#125; return node;&#125;template&lt;class T&gt;Node&lt;T&gt;* AVLTree&lt;T&gt;::findMin(Node&lt;T&gt;* node) &#123; if (node != nullptr) &#123; if (node-&gt;lchild == nullptr) //左孩子为空，当前节点已是最左下 return node; else return findMin(node-&gt;lchild); //左孩子不为空，往左子树遍历 &#125; else return nullptr; //空树返回nullptr&#125;int main() &#123; int arr[]&#123; 7,4,8,5,1,6&#125;;//ll:738512建树;rr:7385129删除2;rl:7385124删除4;lr:748516建树 AVLTree&lt;int&gt; avl; for (int i = 0; i &lt; 6; i++) &#123; avl.insert(arr[i]); &#125; avl.printTree(); avl.find(avl.getRoot(),8); avl.remove(avl.getRoot(), nullptr, 8); avl.printTree();&#125; Above Code from [kite97] 3.6 堆3.6.1 什么是堆优先队列Priority Queue：特殊的队列，取出元素的顺序是按照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。 堆Heap即为优先队列的完全二叉树表示，堆的两个特性： 结构性：用数组表示的完全二叉树； 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值） 最大堆MaxHeap也称“大顶堆”：最大值 最小堆MinHeap也称“小顶堆”：最小值 3.6.2 堆的表示和实现堆抽象数据结构描述 最大堆的操作：创建、插入、删除、维护 定义 12345678910111213141516171819202122typedef struct HNode *Heap; /* 堆的类型定义 */struct HNode &#123; ElementType *Data; /* 存储元素的数组 */ int Size; /* 堆中当前元素个数 */ int Capacity; /* 堆的最大容量 */&#125;;typedef Heap MaxHeap; /* 最大堆 */typedef Heap MinHeap; /* 最小堆 */#define MAXDATA 1000 /* 该值应根据具体情况定义为大于堆中所有可能元素的值 */MaxHeap CreateHeap( int MaxSize )&#123; /* 创建容量为MaxSize的空的最大堆 */ MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (ElementType *)malloc((MaxSize+1)*sizeof(ElementType)); H-&gt;Size = 0; H-&gt;Capacity = MaxSize; H-&gt;Data[0] = MAXDATA; /* 定义&quot;哨兵&quot;为大于堆中所有可能元素的值*/ return H;&#125; 插入 通过一个示例来理解堆插入的过程，将16插入到下面的堆中 `16` 被添加最后一行的第一个空位。不行的是，现在堆属性不满足，因为 `2` 在 `16` 的上面，我们需要将大的数字在上面（这是一个最大堆）为了恢复堆属性，我们需要交换 `16` 和 `2`。现在还没有完成，因为 `10` 也比 `16` 小。我们继续交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。这就是所谓的 **shift-up**，每一次插入操作后都需要进行。它将一个太大或者太小的数字“浮起”到树的顶部。 12345678910111213141516171819202122bool IsFull( MaxHeap H )&#123; return (H-&gt;Size == H-&gt;Capacity);&#125;//将新增结点插入到从其父结点到根节点的有序序列中bool Insert( MaxHeap H, ElementType X )&#123; /* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */ int i; if ( IsFull(H) ) &#123; printf(&quot;最大堆已满&quot;); return false; &#125; i = ++H-&gt;Size; /* i指向插入后堆中的最后一个元素的位置 */ //哨兵起到一个边界判定的作用，若是没有在data[0]设置哨兵元素则判定条件应为 H-&gt;Data[i/2] &lt; X &amp;&amp; i&gt;1 for ( ; H-&gt;Data[i/2] &lt; X; i/=2 ) //当父结点小于当前结点时进行交换 H-&gt;Data[i] = H-&gt;Data[i/2]; /* 上滤X */ H-&gt;Data[i] = X; /* 将X插入 */ return true;&#125; 删除 我们将这个树中的 10 删除，但在删除后顶部空出了一个节点，很自然的我们要从下面找到合适的结点来维持堆的属性。 当插入节点的时候，我们将新的值返给数组的尾部。现在我们来做相反的事情：我们取出数组中的最后一个元素，将它放到树的顶部，然后再修复堆属性。 现在来看怎么 shift-down。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。现在有两个数字可用于交换 7 和 2。我们选择这两者中的较大者称为最大值放在树的顶部，所以交换 7 和 1。 继续堆化直到该节点没有任何子节点或者它比两个子节点都要大为止。对于我们的堆，我们只需要再有一次交换就恢复了堆属性。 实质的核心思想就是：已知左子树是一个堆，右子树也是一个堆，对于一个新的元素，要如何将其调整为一个堆。 123456789101112131415161718192021222324252627282930313233343536#define ERROR -1 /* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */bool IsEmpty( MaxHeap H )&#123; return (H-&gt;Size == 0);&#125;ElementType DeleteMax( MaxHeap H )&#123; /* 从最大堆H中取出键值为最大的元素，并删除一个结点 */ int Parent, Child; ElementType MaxItem, X; if ( IsEmpty(H) ) &#123; printf(&quot;最大堆已为空&quot;); return ERROR; &#125; MaxItem = H-&gt;Data[1]; /* 取出根结点存放的最大值 */ /* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */ X = H-&gt;Data[H-&gt;Size--]; /* 取最后一个结点，且注意当前堆的规模要减小 */ //将最后一个元素假定为最大值，之后找出其左右儿子中较大的那个替换位置 //之后重复操作到找不到左右儿子，则此时堆的顺序维护完成 for( Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123; Child = Parent * 2; //Child先指向左儿子 if( (Child!=H-&gt;Size) //child!=H-&gt;Size意味着一定存在右儿子 &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) ) Child++; /* Child指向左右子结点的较大者 */ if( X &gt;= H-&gt;Data[Child] ) break; /* 找到了合适位置 */ else /* 下滤X */ H-&gt;Data[Parent] = H-&gt;Data[Child]; &#125; H-&gt;Data[Parent] = X; return MaxItem;&#125; 给定n个元素进行创建 方法一：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为$O(Nlog{N})$ 方法二：在线性时间复杂度下建立最大堆。 将N个元素按照输入顺序存入，先满足完全二叉树的结构特性； 调整各结点位置，以满足最大堆的有序特性。调整堆时采用删除操作中的方法进行调整，但从下往上进行调整，满足左右子树为堆+1结点的条件。故从最后一个非叶子节点也即最后一个父结点进行调整。 12345678910111213141516171819202122232425262728/*----------- 建造最大堆 -----------*/void PercDown( MaxHeap H, int p )&#123; /* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */ int Parent, Child; ElementType X; X = H-&gt;Data[p]; /* 取出根结点存放的值 */ for( Parent=p; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123; Child = Parent * 2; if( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) ) Child++; /* Child指向左右子结点的较大者 */ if( X &gt;= H-&gt;Data[Child] ) break; /* 找到了合适位置 */ else /* 下滤X */ H-&gt;Data[Parent] = H-&gt;Data[Child]; &#125; H-&gt;Data[Parent] = X;&#125;void BuildHeap( MaxHeap H )&#123; /* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性 */ /* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */ int i; /* 从最后一个结点的父节点（也即最后一个非叶子结点）开始，到根结点1 */ for( i = H-&gt;Size/2; i&gt;0; i-- ) PercDown( H, i );&#125; 3.7 哈夫曼树和哈夫曼编码3.7.1 什么是哈夫曼树带权路径长度WPL：设二叉树有n个叶子结点，每个叶子结点带有权值$W_k$，从根结点到每个叶子结点的长度为$l_k$，则每个叶子结点的带权路径长度之和就是：$WPL=\\sum^n_{k=1}w_kl_k$ 最优二叉树/哈夫曼树：WPL最小的二叉树 3.7.2 哈夫曼树的构造每次把权值最小的两棵二叉树合并（利用构造最小堆可以很好地实现） 123456789101112131415161718typedef struct TreeNode *HuffmanTree;struct TreeNode&#123; int Weight; HuffmanTree Left,Right;&#125;;HuffmanTree Huffman(MinHeap H)&#123; //假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里 int i; HuffmanTree T; BuildMinHeap(H); //将H-&gt;Elements[]按照权值调整为最小堆 for(i=1;i&lt;H-&gt;Size;i++)&#123; //做H-&gt;Size-1次合并 T=malloc(sizeof(struct TreeNode)); T-&gt;Left=DeleteMin(H); T-&gt;Right=DeleteMin(H); //从最小堆中取出两个最小的节点作为左右节点 T-&gt;Weight=T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight; //重新计算权值 Insert(H,T); //将新的T插入到最小堆中 &#125;&#125; 3.7.3 哈夫曼树的特点 没有度为1的结点 n个叶子结点的哈夫曼树共有2n-1个结点 哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树 对同一组权值${w_1,w_2,\\dots,w_n}$，存在不同构的哈夫曼树，但WPL值是一样的 3.7.4 哈夫曼编码给定一段字符串，使用哈夫曼编码进行编码（不等长编码）可以使得该字符串的编码存储空间最小 在不等长编码中，为避免二义性，需要满足前缀码prefix code要求（任何字符的编码都不是另一字符编码的前缀），用二叉树表示编码即可完美避免二义性 3.8 集合及运算3.8.1 集合的表示 集合运算：交、并、补、差，判定一个元素是否属于某一集合 并查集：集合并、查某元素属于什么集合 并查集问题中使用树的结构存储集合，树的每一个结点代表一个集合元素 3.8.2 并查集的实现 采用数组存储形式 查找某个元素所在的集合（用根结点表示） 1234567891011121314151617181920212223#define MAXN 1000 /* 集合最大元素个数 */typedef int ElementType; /* 默认元素可以用非负整数表示 */typedef int SetName; /* 默认用根结点的下标作为集合名称 */typedef ElementType SetType[MAXN]; /* 假设集合元素下标从0开始 */SetName Find( SetType S, ElementType X )&#123; /* 默认集合元素全部初始化为-1 */ if ( S[X] &lt; 0 ) /* 找到集合的根 */ return X; else return S[X] = Find( S, S[X] ); /* 路径压缩 */&#125;//循环实现int Find(SetType S[],ElementType X)&#123; //在数组S中查找值为X的元素所对应的集合 //MaxSize是全局变量，为数组S的最大长度 int i; for(i=0;i&lt;MaxSize &amp;&amp; S[i].Data!=X;i++); if(i&gt;=MaxSize)return -1; //未找到X，返回-1 for(;S[i].Parent&gt;=0;i=S[i].Parent); return i; //找到x所属集合，返回树根结点在数组S中的下标&#125; 集合的并运算 分别找到X1和X2两个元素所在的集合树的根结点 如果他们不同根，则将其中一个根节点的父结点指针设置为另一个根结点的数组下标 123456789101112131415161718192021void Union(SetType S[],ElementType X1,ElementType X2)&#123; int Root1,Root2; Root1=Find(S,X1); Root2=Find(S,X2); if(Root1!=Root2)S[Root2].Parent=Root1;&#125;//这种固定将root2挂在root1下的方式会导致树的深度越来越深，影响find的效率//于是通过负数判定是否为根结点，而负数的绝对值则表示节点的个数，通过简单的修改，在判断时对两个集合的个数进行修改即可更具效率void Union( SetType S, SetName Root1, SetName Root2 )&#123; /* 这里默认Root1和Root2是不同集合的根结点 */ /* 保证小集合并入大集合 */ if ( S[Root2] &lt; S[Root1] ) &#123; /* 如果集合2比较大 */ S[Root2] += S[Root1]; /* 集合1并入集合2 */ S[Root1] = Root2; &#125; else &#123; /* 如果集合1比较大 */ S[Root1] += S[Root2]; /* 集合2并入集合1 */ S[Root2] = Root1; &#125;&#125; 第四章 图3.1 什么是图图Graph表示多对多的关系，包含一组顶点（通常用$V(Vertex)$）表示顶点集合，一组边（通常用$E(Edge)$）表示边的集合： 边是顶点对：$(v,w)\\in E$，其中$v,w\\in V$ 有向边$&lt;v,w&gt;$表示从$v$指向$w$的边（单向） 不考虑重边和自回路 抽象数据类型定义 图的表示 邻接矩阵$G[N][N]$，$N$个定点从0到$N-1$的编号$$G[i][j]=\\left{\\begin{aligned}1 &amp;&amp; 若&lt;v_i,v_j&gt;是G中的边 \\0 &amp;&amp; 否则\\end{aligned}\\right.$$ 对于无向图，可以使用一个长度为$N(N+1)/2$的一维数组$A$存储${G_{00},G_{10},G_{11},\\dots,G_{n-1 \\ 0},\\dots,G_{n-1 \\ n-1}}$，则$G_{ij}$在$A$中而对应的下标是$(i*(i+1)/2+j)$ 邻接矩阵的优点： 简单直观好理解 方便检查任意一队顶点间是否存在边 方便找任一顶点的所有“邻接点”（有边直接相连的顶点） 方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数为“入度”）。无向图的度为对应行/列的非零元素个数；有向图对应行非零元素个数为出度，对应列非零元素个数为入度 邻接矩阵的缺点： 浪费空间：对于稀疏图（点很多，边很少）有大量无效元素，而对于稠密图（特别是完全图）还是很合算的 浪费时间：统计稀疏图一共有多少条边 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 图的邻接矩阵表示法 */#define MaxVertexNum 100 /* 最大顶点数设为100 */#define INFINITY 65535 /* ∞设为双字节无符号整数的最大值65535*/typedef int Vertex; /* 用顶点下标表示顶点,为整型 */typedef int WeightType; /* 边的权值设为整型 */typedef char DataType; /* 顶点存储的数据类型设为字符型 *//* 边的定义 */typedef struct ENode *PtrToENode;struct ENode&#123; Vertex V1, V2; /* 有向边&lt;V1, V2&gt; */ WeightType Weight; /* 权重 */&#125;;typedef PtrToENode Edge; /* 图结点的定义 */typedef struct GNode *PtrToGNode;struct GNode&#123; int Nv; /* 顶点数 */ int Ne; /* 边数 */ WeightType G[MaxVertexNum][MaxVertexNum]; /* 邻接矩阵 */ DataType Data[MaxVertexNum]; /* 存顶点的数据 */ /* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */&#125;;typedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */MGraph CreateGraph( int VertexNum )&#123; /* 初始化一个有VertexNum个顶点但没有边的图 */ Vertex V, W; MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); /* 建立图 */ Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; /* 初始化邻接矩阵 */ /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */ for (V=0; V&lt;Graph-&gt;Nv; V++) for (W=0; W&lt;Graph-&gt;Nv; W++) Graph-&gt;G[V][W] = INFINITY; return Graph; &#125; void InsertEdge( MGraph Graph, Edge E )&#123; /* 插入边 &lt;V1, V2&gt; */ Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight; /* 若是无向图，还要插入边&lt;V2, V1&gt; */ Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;&#125;MGraph BuildGraph()&#123; MGraph Graph; Edge E; Vertex V; int Nv, i; scanf(&quot;%d&quot;, &amp;Nv); /* 读入顶点个数 */ Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne)); /* 读入边数 */ if ( Graph-&gt;Ne != 0 ) &#123; /* 如果有边 */ E = (Edge)malloc(sizeof(struct ENode)); /* 建立边结点 */ /* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */ for (i=0; i&lt;Graph-&gt;Ne; i++) &#123; scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); /* 注意：如果权重不是整型，Weight的读入格式要改 */ InsertEdge( Graph, E ); &#125; &#125; /* 如果顶点有数据的话，读入数据 */ for (V=0; V&lt;Graph-&gt;Nv; V++) scanf(&quot; %c&quot;, &amp;(Graph-&gt;Data[V])); return Graph;&#125; 邻接表：$G[N]$为指针数组，对应矩阵每行一个链表，只存非零元素 邻接表优点： 方便找任一顶点的所有邻接点 节约稀疏图的空间：需要N个头指针+2E个结点（每个指针至少两个域） 对于无向图方便计算任一顶点的度；而对于有向图则只能计算出度，需要构造逆邻接表来方便计算出度 邻接表缺点：不方便检查任意一对顶点间是否存在边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 图的邻接表表示法 */#define MaxVertexNum 100 /* 最大顶点数设为100 */typedef int Vertex; /* 用顶点下标表示顶点,为整型 */typedef int WeightType; /* 边的权值设为整型 */typedef char DataType; /* 顶点存储的数据类型设为字符型 *//* 边的定义 */typedef struct ENode *PtrToENode;struct ENode&#123; Vertex V1, V2; /* 有向边&lt;V1, V2&gt; */ WeightType Weight; /* 权重 */&#125;;typedef PtrToENode Edge;/* 邻接点的定义 */typedef struct AdjVNode *PtrToAdjVNode; struct AdjVNode&#123; Vertex AdjV; /* 邻接点下标 */ WeightType Weight; /* 边权重 */ PtrToAdjVNode Next; /* 指向下一个邻接点的指针 */&#125;;/* 顶点表头结点的定义 */typedef struct Vnode&#123; PtrToAdjVNode FirstEdge;/* 边表头指针 */ DataType Data; /* 存顶点的数据 */ /* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */&#125; AdjList[MaxVertexNum]; /* AdjList是邻接表类型 *//* 图结点的定义 */typedef struct GNode *PtrToGNode;struct GNode&#123; int Nv; /* 顶点数 */ int Ne; /* 边数 */ AdjList G; /* 邻接表 */&#125;;typedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */LGraph CreateGraph( int VertexNum )&#123; /* 初始化一个有VertexNum个顶点但没有边的图 */ Vertex V; LGraph Graph; Graph = (LGraph)malloc( sizeof(struct GNode) ); /* 建立图 */ Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; /* 初始化邻接表头指针 */ /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */ for (V=0; V&lt;Graph-&gt;Nv; V++) Graph-&gt;G[V].FirstEdge = NULL; return Graph; &#125; void InsertEdge( LGraph Graph, Edge E )&#123; PtrToAdjVNode NewNode; /* 插入边 &lt;V1, V2&gt; */ /* 为V2建立新的邻接点 */ NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; /* 将V2插入V1的表头 */ NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge; Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode; /* 若是无向图，还要插入边 &lt;V2, V1&gt; */ /* 为V1建立新的邻接点 */ NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; /* 将V1插入V2的表头 */ NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge; Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;&#125;LGraph BuildGraph()&#123; LGraph Graph; Edge E; Vertex V; int Nv, i; scanf(&quot;%d&quot;, &amp;Nv); /* 读入顶点个数 */ Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne)); /* 读入边数 */ if ( Graph-&gt;Ne != 0 ) &#123; /* 如果有边 */ E = (Edge)malloc( sizeof(struct ENode) ); /* 建立边结点 */ /* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */ for (i=0; i&lt;Graph-&gt;Ne; i++) &#123; scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); /* 注意：如果权重不是整型，Weight的读入格式要改 */ InsertEdge( Graph, E ); &#125; &#125; /* 如果顶点有数据的话，读入数据 */ for (V=0; V&lt;Graph-&gt;Nv; V++) scanf(&quot; %c&quot;, &amp;(Graph-&gt;G[V].Data)); return Graph;&#125; 3.2 图的遍历","categories":[],"tags":[{"name":"数据结构, 算法","slug":"数据结构-算法","permalink":"http://lethewind.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}]},{"title":"激活函数","slug":"激活函数","date":"2021-09-18T04:17:19.000Z","updated":"2021-10-11T05:28:33.350Z","comments":true,"path":"2021/09/18/激活函数/","link":"","permalink":"http://lethewind.github.io/2021/09/18/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-09-18T03:18:50.091Z","updated":"2021-09-18T03:18:50.092Z","comments":true,"path":"2021/09/18/hello-world/","link":"","permalink":"http://lethewind.github.io/2021/09/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"数据结构, 算法","slug":"数据结构-算法","permalink":"http://lethewind.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}]}