<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lethewind.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="数据结构（ZJU-MOOC）第一讲 基本概念1.1 什么是数据结构 数据结构是计算机中存储、组织数据的方式。通常情况下，精心准备的数据结构可以带来最有效率的算法。  通常来说代码的效率与数据的规模直接挂钩，通过将大规模的问题缩小到小规模的问题的方法，往往有奇效。  递归对于空间的占用是极为恐怖的。  时间库&lt;time.h&gt;的使用方法   123456789101112131415161">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构笔记（基于浙大MOOC）">
<meta property="og:url" content="http://lethewind.github.io/2021/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%B5%99%E5%A4%A7MOOC%EF%BC%89/index.html">
<meta property="og:site_name" content="Lethe">
<meta property="og:description" content="数据结构（ZJU-MOOC）第一讲 基本概念1.1 什么是数据结构 数据结构是计算机中存储、组织数据的方式。通常情况下，精心准备的数据结构可以带来最有效率的算法。  通常来说代码的效率与数据的规模直接挂钩，通过将大规模的问题缩小到小规模的问题的方法，往往有奇效。  递归对于空间的占用是极为恐怖的。  时间库&lt;time.h&gt;的使用方法   123456789101112131415161">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/10/02/6HAYQLJvOD5ySVB.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/FqSpLcZAVo8aYs7.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/ntKsqudSzQR4f6G.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/nmvij4yx1sAQH3Y.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/Hh5RUOaZevdwBLu.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/XU7zn6tJTfe9YaG.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/2Ub1f9BJqPeAwig.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/nJbxkDp5NFKoAGU.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/ajxRqbdByVm7Hf2.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/3nHPFRsdqlWigmI.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/nfKcALD5XTYZqav.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/wmiGW92ZqKet83b.png">
<meta property="og:image" content="https://i.loli.net/2021/10/02/Yru9Zg8AlFS4LJb.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/DoVUj2NelJuFtfI.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/zeiPoKyNdLw5H7W.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/qCHwAgDP8dk2YU4.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/Cy73TKJzsPctYpg.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/5IPq7shkOrE4jA2.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/4eqsA2lmYnydjzO.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/v5oWs7NMQcCgDEK.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/7Pzga3UrwY2WDjF.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/aGwoOLUbhe5Ay1K.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/fDRFlQwJt7kTpcy.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/6uWiYyUDK7RlFpA.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/27Qe9J5phEuKbrI.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/ST1XvNLK2cOwu3y.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/uLGN2IbQHOPiED5.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/ux5Bjhp9LlSfGac.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/BoU5hHz8NS6wxRW.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/m4rj3PxYsC5gaek.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/ke18YHGotfQIrhb.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/AHuw3xQI4lf6pga.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/mrRnDlUBsH4KYAM.png">
<meta property="og:image" content="https://i.loli.net/2021/10/03/jlXLYTpcgxVA1nJ.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/KeXUScZgn3szuQ8.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/eNasRGHiCxMf67j.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/WGpoKJB1r8Hwtdf.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/ueM9ht7maRIDbdz.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/b7wca1zp8rB54Ed.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/wuAUOPrlg7yVZcS.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/gfwtDoRcKVAY3O7.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/NA7QDyCEPqBthLJ.png">
<meta property="og:image" content="c:/Users/Farewellswind/AppData/Roaming/Typora/typora-user-images/image-20211005140052019.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/BcZGRdhWjwHyQYN.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/N9UovASgp5hBjbM.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/cMNbiIVW6yDOhsQ.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/xCXqEcDa2nIUzrT.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/Pxuh8mvDQSdOrzj.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/8JG5IVShalLCWQA.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/KBk46Es9yJxVSri.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/A6q7bGdSuYc4gP9.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/opd5KiryJb3c2C1.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/fKX2QoUetuHxi61.gif">
<meta property="og:image" content="https://i.loli.net/2021/10/05/ZmF5w6kNKu4fShd.gif">
<meta property="og:image" content="https://i.loli.net/2021/10/05/ONnJLiGt9lXsjUv.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/acBSZzGjt6l7FbH.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/LqBR3FzQpHaNPn9.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/85soJvICwX4qgEU.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/CkGU6YNpHtmF5BO.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/sgDbZMKTGiHnUrp.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-51fd43a2d2191488.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-7dd89da71927acb8.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-785a7a6cd104f775.png?imageMogr2/auto-orient/strip|imageView2/2/w/204/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-d7dae273e1f5a0ba.png?imageMogr2/auto-orient/strip|imageView2/2/w/192/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-7eb32c6486a44f73.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-71783aa7bd24a51f.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-c28b15dc371b8e97.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-bfc42e89b5411f9b.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-8b04275965f88961.png?imageMogr2/auto-orient/strip|imageView2/2/w/208/format/webp">
<meta property="og:image" content="https://i.loli.net/2021/10/05/6sCTXAVmzJc9Wvg.png">
<meta property="og:image" content="https://i.loli.net/2021/10/05/AETuNp6BUaklXHJ.png">
<meta property="og:image" content="https://i.loli.net/2021/10/06/UhvN78oTbS3OncG.png">
<meta property="og:image" content="https://i.loli.net/2021/10/06/6MAHl5WPEkhK1Lt.png">
<meta property="og:image" content="https://i.loli.net/2021/10/06/eMtvDYJ4ymHg2dA.png">
<meta property="article:published_time" content="2021-10-11T05:30:24.000Z">
<meta property="article:modified_time" content="2021-10-11T05:32:06.368Z">
<meta property="article:author" content="Farewellswind">
<meta property="article:tag" content="数据结构, 算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/10/02/6HAYQLJvOD5ySVB.png">

<link rel="canonical" href="http://lethewind.github.io/2021/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%B5%99%E5%A4%A7MOOC%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构笔记（基于浙大MOOC） | Lethe</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Lethe" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lethe</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Farewellswind Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lethewind.github.io/2021/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%B5%99%E5%A4%A7MOOC%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Farewellswind">
      <meta itemprop="description" content="Blog to record sth. powered by GitPages & Hexo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构笔记（基于浙大MOOC）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-11 13:30:24 / 修改时间：13:32:06" itemprop="dateCreated datePublished" datetime="2021-10-11T13:30:24+08:00">2021-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据结构（ZJU-MOOC）"><a href="#数据结构（ZJU-MOOC）" class="headerlink" title="数据结构（ZJU-MOOC）"></a>数据结构（ZJU-MOOC）</h1><h2 id="第一讲-基本概念"><a href="#第一讲-基本概念" class="headerlink" title="第一讲 基本概念"></a>第一讲 基本概念</h2><h3 id="1-1-什么是数据结构"><a href="#1-1-什么是数据结构" class="headerlink" title="1.1 什么是数据结构"></a>1.1 什么是数据结构</h3><ul>
<li><p>数据结构是计算机中存储、组织数据的方式。通常情况下，精心准备的数据结构可以带来最有效率的算法。</p>
</li>
<li><p>通常来说代码的效率与数据的规模直接挂钩，通过将大规模的问题缩小到小规模的问题的方法，往往有奇效。</p>
</li>
<li><p>递归对于空间的占用是极为恐怖的。</p>
</li>
<li><p>时间库&lt;time.h&gt;的使用方法</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> start, stop;</span><br><span class="line"><span class="comment">/* clock_t 是clock()函数返回的变量类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> duration;</span><br><span class="line"><span class="comment">/* 用来记录运行时间，以秒为单位 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 不在测试范围之前的准备工作写在clock()调用之前 */</span></span><br><span class="line">    start = <span class="built_in">clock</span>(); <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyFunction</span>(); <span class="comment">//把测试函数写在这里</span></span><br><span class="line"></span><br><span class="line">    stop = <span class="built_in">clock</span>();</span><br><span class="line">    duration = ((<span class="keyword">double</span>)(stop - start))/CLK_TCK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他不在测试范围的处理写在后面，例如输出duration的值 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数据结构是数据对象在计算机中的组织方式，数据对象一定与一系列加在其之上的操作相关联，完成这些操作所用的方法就是算法</p>
</li>
<li><p>线性结构 1 to 1</p>
<p>树形结构 1 to n</p>
<p>图      n to n</p>
</li>
<li><p>抽象数据类型</p>
<p>数据对象集</p>
<p>数据集合相关联的操作集</p>
</li>
</ul>
<h3 id="1-2-什么是算法"><a href="#1-2-什么是算法" class="headerlink" title="1.2 什么是算法"></a>1.2 什么是算法</h3><ul>
<li><p>算法的定义（一个有限的指令集，输入输出，在有限的步骤后停止，每一条指令都必须有明确的目标且不存在歧义，在计算机处理范围内，描述应不依赖于任何一种计算机语言以及具体的实现手段）</p>
</li>
<li><p>算法的评价指标</p>
<ul>
<li>空间复杂度$S(n)$</li>
<li>时间复杂度$O(n)$</li>
</ul>
</li>
<li><p>乘除法的时间消耗比加减法高很多，在时间复杂度计算的过程中权重更高</p>
</li>
<li><p>在分析一般算法的效率时，我们经常关注下面两种复杂度</p>
<ul>
<li>最坏情况复杂度$T_{worst}(n)$</li>
<li>平均复杂度$T_{avg}(n)$</li>
</ul>
<p>$T_{avg}(n)\le T_{worst}(n)$</p>
</li>
<li><p>复杂度的渐进表示法</p>
<p><img src="https://i.loli.net/2021/10/02/6HAYQLJvOD5ySVB.png" alt="image-20211002111912317"></p>
<p><img src="https://i.loli.net/2021/10/02/FqSpLcZAVo8aYs7.png" alt="image-20211002115340535"></p>
</li>
</ul>
<h3 id="1-3-应用实例：最大子列和问题"><a href="#1-3-应用实例：最大子列和问题" class="headerlink" title="1.3 应用实例：最大子列和问题"></a>1.3 应用实例：最大子列和问题</h3><p>问题描述：给定$N$个整数的序列${A_1,A_2,\dots,A_N}$,求函数$f(i,j)=max{0,\sum^j_{k=1}A_k}$的最大值</p>
<ul>
<li><p>算法一：暴力搜索，计算出所有子列和，$O(n^3)$</p>
<p><img src="https://i.loli.net/2021/10/02/ntKsqudSzQR4f6G.png" alt="image-20211002120659001"></p>
</li>
<li><p>算法二：利用前缀和，减少一层循环，$O(n^2)$</p>
<p><img src="https://i.loli.net/2021/10/02/nmvij4yx1sAQH3Y.png" alt="image-20211002120712907"></p>
</li>
<li><p>算法三：分治思想，分成两段分别寻找最大子列和，然后合并寻找最大子列和，$O(n\log{n})$</p>
<p><img src="https://i.loli.net/2021/10/02/Hh5RUOaZevdwBLu.png" alt="image-20211002120637483"></p>
</li>
<li><p>算法四：在线处理（指每输入一个数据就进行即时处理，在任何一个地方中止输入，算法都能正确给出当前解），$O(N)$</p>
<p><img src="https://i.loli.net/2021/10/02/XU7zn6tJTfe9YaG.png" alt="image-20211002121207191"></p>
</li>
</ul>
<h2 id="第二讲-线性结构"><a href="#第二讲-线性结构" class="headerlink" title="第二讲 线性结构"></a>第二讲 线性结构</h2><h3 id="2-1-线性表及其实现"><a href="#2-1-线性表及其实现" class="headerlink" title="2.1 线性表及其实现"></a>2.1 线性表及其实现</h3><h4 id="2-1-1-多项式的表示"><a href="#2-1-1-多项式的表示" class="headerlink" title="2.1.1 多项式的表示"></a>2.1.1 多项式的表示</h4><p>一元多项式$f(x)=a_0+a_1x+\dots+a_{n-1}x^{n-1}+a_n x^n$及其计算（多项式相加、相减、相乘）</p>
<ul>
<li><p>方法一：顺序存储结构直接表示（每一位固定存储对应的指数级的系数）</p>
<p>造成大量浪费，诸如$x+3x^{2000}$</p>
</li>
<li><p>方法二：顺序存储结构表示非零项（使用结构数组表示，数组分量表示系数和指数，按照指数大小有序存储即可方便计算）</p>
</li>
<li><p>方法三：链表结构存储非零项（链表中每个节点存储多项式的一个非零项，包括系数和指数两个数据域以及一个指针域用于指向下一个节点）</p>
</li>
</ul>
<p>多项式表示问题的启示：</p>
<ul>
<li>同一个问题可以有不同的表示、存储方式</li>
<li>有一类共性问题：有序线性序列的组织和管理</li>
</ul>
<h4 id="2-1-2-线性表的实现"><a href="#2-1-2-线性表的实现" class="headerlink" title="2.1.2 线性表的实现"></a>2.1.2 线性表的实现</h4><p><strong>线性表</strong>(<code>Linear List</code>)：由同类型数据元素构成的有序序列的线性结构</p>
<ul>
<li>表中元素个数称为长度</li>
<li>线性表没有元素时，称为空表</li>
<li>表起始位置称表头，结束位置称表尾</li>
</ul>
<p><strong>线性表的抽象数据类型描述</strong></p>
<p><img src="https://i.loli.net/2021/10/02/2Ub1f9BJqPeAwig.png" alt="image-20211002123339372"></p>
<p><strong>主要操作的实现</strong></p>
<ul>
<li><p>数组方式</p>
<ul>
<li><p>插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=PtrL-&gt;Last;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">    PtrL-&gt;Data[j+<span class="number">1</span>]=PtrL-&gt;Data[j];  <span class="comment">/*将a[i]~a[n]倒序向后移动*/</span></span><br><span class="line">PtrL-&gt;Data[i<span class="number">-1</span>]=X;					<span class="comment">/*新元素插入*/</span></span><br><span class="line">PtrL-&gt;Last++;						<span class="comment">/*Last依然指向最后元素*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>删除</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=i;j&lt;=PtrL-&gt;Last;j++)</span><br><span class="line">    PtrL-&gt;Data[j<span class="number">-1</span>]=PtrL-&gt;Data[j];  <span class="comment">/*将a[i+1]~a[n]顺序向后移动*/</span></span><br><span class="line">PtrL-&gt;Last--;						<span class="comment">/*Last依然指向最后元素*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>链表方式</p>
<ul>
<li><p>组织形式</p>
<p><img src="https://i.loli.net/2021/10/02/nJbxkDp5NFKoAGU.png" alt="image-20211002125029064"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElementType Data;</span><br><span class="line">List Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> <span class="title">L</span>;</span></span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure></li>
<li><p>求表长（遍历一遍）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List PtrL)</span></span>&#123;</span><br><span class="line">    List p=PtrL;	<span class="comment">/*p指向表的第一个节点*/</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;		<span class="comment">/*当前p指向的是第j个节点*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按照序号查找*/</span></span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List PtrL)</span></span>&#123;</span><br><span class="line">    List p=PtrL;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;i&lt;K)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==K)<span class="keyword">return</span> p;	<span class="comment">/*找到第K个，返回指针*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">/*否则返回空*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*按照数据值进行查找*/</span></span><br><span class="line"><span class="function">List <span class="title">Find</span><span class="params">(List PtrL,ElementType X)</span></span>&#123;</span><br><span class="line">    List p=PtrL; <span class="comment">/* p指向L的第1个结点 */</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;Data!=X)</span><br><span class="line">        p=p-&gt;Next;</span><br><span class="line">    <span class="comment">/* 下列语句可以用 return p; 替换 */</span></span><br><span class="line">    <span class="keyword">if</span>(p)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>插入</p>
<ul>
<li>先构造一个新节点，用s指向；</li>
<li>再找到链表的第$i-1$个节点，用p指向；</li>
<li>然后修改指针，插入节点（p之后插入新节点s）。</li>
</ul>
<p><img src="https://i.loli.net/2021/10/02/ajxRqbdByVm7Hf2.png" alt="image-20211002130707569"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    List p,s;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;									 <span class="comment">/*新节点插入在表头*/</span></span><br><span class="line">        s=(List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));	<span class="comment">/*申请、装填节点*/</span></span><br><span class="line">        s-&gt;Data=X;</span><br><span class="line">        s-&gt;Next=PtrL;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    p=<span class="built_in">FindKth</span>(i<span class="number">-1</span>,PtrL);						<span class="comment">/*查找第i-1个节点*/</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;								<span class="comment">/*第i-1个节点不存在*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s=(List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        s-&gt;Data=X;</span><br><span class="line">        s-&gt;Next=p-&gt;Next;						<span class="comment">/*新节点插入在第i-1个节点之后*/</span></span><br><span class="line">        p-&gt;Next=s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除</p>
<ul>
<li>先找到链表的第$i-1$个节点，用p指向；</li>
<li>再用指针s指向要被删除的节点（p的下一个节点）；</li>
<li>然后修改指针，删除s所指节点；</li>
<li>最后释放s所指的节点的空间。</li>
</ul>
<p><img src="https://i.loli.net/2021/10/02/3nHPFRsdqlWigmI.png" alt="image-20211002134056397"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Dlete</span><span class="params">(<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    List p,s;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        s=PtrL;</span><br><span class="line">        <span class="keyword">if</span>(PtrL!=<span class="literal">NULL</span>)PtrL=PtrL-&gt;Next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">    p=<span class="built_in">FindKth</span>(i<span class="number">-1</span>,PtrL);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个节点不存在&quot;</span>,i<span class="number">-1</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个节点不存在&quot;</span>,i);<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        s=p-&gt;Next;							<span class="comment">/*s指向第i个节点*/</span></span><br><span class="line">        p-&gt;Next=s-&gt;Next;					<span class="comment">/*从链表中删除*/</span></span><br><span class="line">        <span class="built_in">free</span>(s);							<span class="comment">/*释放被删除节点空间*/</span></span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-1-3-广义表"><a href="#2-1-3-广义表" class="headerlink" title="2.1.3 广义表"></a>2.1.3 广义表</h4><p>广义表是线性表的推广，对于线性表来说，n个元素都是基本的单元素，广义表中，这些元素不仅可以是单元素也可以是另一个广义表。</p>
<p>双向链表、多重链表</p>
<p>矩阵尤其是稀疏矩阵，使用多重链表中的十字链表进行存储更有利于节省存储空间</p>
<h3 id="2-2-堆栈"><a href="#2-2-堆栈" class="headerlink" title="2.2 堆栈"></a>2.2 堆栈</h3><h4 id="2-2-1-什么是堆栈"><a href="#2-2-1-什么是堆栈" class="headerlink" title="2.2.1 什么是堆栈"></a>2.2.1 什么是堆栈</h4><p>堆栈<code>Stack</code>：具有一定操作约束的线性表，只能在一端（栈顶，top）做插入和删除（先进后出<code>Last In First Out</code>）</p>
<p>插入数据：入栈<code>Push</code>，删除数据：出栈<code>Pop</code></p>
<p><strong>堆栈的抽象数据类型</strong>描述：</p>
<p><img src="https://i.loli.net/2021/10/02/nfKcALD5XTYZqav.png" alt="image-20211002140528389"></p>
<h4 id="2-2-2-堆栈的实现"><a href="#2-2-2-堆栈的实现" class="headerlink" title="2.2.2 堆栈的实现"></a>2.2.2 堆栈的实现</h4><ul>
<li><p>数组实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack PtrS,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PtrS-&gt;Top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Full&quot;</span>);<span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top)]=item;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack PtrS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PtrS-&gt;Top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (PtrS-&gt;Data[(PtrS-&gt;Top)--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链表实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    S=(Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    S-&gt;Next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S-&gt;Next==<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(ElementType item,Stack S)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">TmpCell</span>;</span></span><br><span class="line">    TmpCell=(struct SNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    TmpCell-&gt;Element=item;</span><br><span class="line">    TmpCell-&gt;Next=S-&gt;Next;</span><br><span class="line">    S-&gt;Next=TmpCell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*可以看到链表的堆栈是以链表头为栈顶，在此处进行插入和删除实现的*/</span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">FirstCell</span>;</span></span><br><span class="line">    ElementType TopElem;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty&quot;</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        FirstCell=S-&gt;Next;</span><br><span class="line">        S-&gt;Next=FirstCell-&gt;Next;</span><br><span class="line">        TopElem=FirstCell-&gt;Element;</span><br><span class="line">        <span class="built_in">free</span>(FirstCell);</span><br><span class="line">        <span class="keyword">return</span> TopElem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-3-表达式求值"><a href="#2-2-3-表达式求值" class="headerlink" title="2.2.3 表达式求值"></a>2.2.3 表达式求值</h4><p><img src="https://i.loli.net/2021/10/02/wmiGW92ZqKet83b.png" alt="image-20211002142758551"></p>
<p>中缀表达式：$a+b*c-d/e$</p>
<p>后缀表达式：$abc*+de/-$</p>
<p>后缀表达式求值策略：从左向右“扫描”，逐个处理运算数和运算符号；遇到运算数时压栈，遇到运算符号时从堆栈中弹出适当的运算数，计算结构后入栈；最后栈顶元素就是表达式的结果。 </p>
<p><strong>中缀表达式转后缀表达式</strong></p>
<p><img src="https://i.loli.net/2021/10/02/Yru9Zg8AlFS4LJb.png" alt="image-20211002142833489"></p>
<h3 id="2-3-队列"><a href="#2-3-队列" class="headerlink" title="2.3 队列"></a>2.3 队列</h3><h4 id="2-3-1-什么是队列"><a href="#2-3-1-什么是队列" class="headerlink" title="2.3.1 什么是队列"></a>2.3.1 什么是队列</h4><p>队列<code>Queue</code>：具有一定操作约束的线性表，只能在一端插入，另一端删除，即先进先出。</p>
<p>数据插入：入队列<code>AddQ</code>，数据删除：出队列<code>DeleteQ</code>，先进先出<code>FIFO</code></p>
<p><strong>队列的抽象数据类型描述</strong></p>
<p><img src="https://i.loli.net/2021/10/03/DoVUj2NelJuFtfI.png" alt="image-20211003101155512"></p>
<h4 id="2-3-2-队列的实现"><a href="#2-3-2-队列的实现" class="headerlink" title="2.3.2 队列的实现"></a>2.3.2 队列的实现</h4><ul>
<li><p>数组实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//思考循环链表判断队列空和满的条件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue PtrQ,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;rear+<span class="number">1</span>==MaxSize)&#123;</span><br><span class="line">        <span class="comment">//(PtrQ-&gt;rear+1)%MaxSize==PtrQ-&gt;front</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Full&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//PtrQ-&gt;rear=(PtrQ-&gt;rear+1)%MaxSize;</span></span><br><span class="line">    <span class="comment">//PtrQ-&gt;Data[PtrQ-&gt;rear]=item;</span></span><br><span class="line">    PtrQ-&gt;Data[++PtrQ-&gt;rear]=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue PtrQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front==PtrQ-&gt;rear)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//PtrQ-&gt;front=(PtrQ-&gt;front+1)%MaxSize;</span></span><br><span class="line">        <span class="comment">//return PtrQ-&gt;Data[PtrQ-&gt;front];</span></span><br><span class="line">        <span class="keyword">return</span> PtrQ[PtrQ-&gt;front++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链表实现</p>
<p><img src="https://i.loli.net/2021/10/03/zeiPoKyNdLw5H7W.png" alt="image-20211003102506254"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line">Queue PtrQ;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue PtrQ)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">FrontCell</span>;</span></span><br><span class="line">    ElementType FrontElem;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    FrontCell=PtrQ-&gt;front;</span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front==PtrQ-&gt;rear)<span class="comment">//若队列只有一个元素</span></span><br><span class="line">        PtrQ-&gt;front=PtrQ-&gt;rear=<span class="literal">NULL</span>;<span class="comment">//删除后置队列为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PtrQ-&gt;front=PtrQ-&gt;front-&gt;Next;</span><br><span class="line">    FrontElem=FrontCell-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>(FrontCell);<span class="comment">//释放被删除节点空间</span></span><br><span class="line">    <span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第三章-树"><a href="#第三章-树" class="headerlink" title="第三章 树"></a>第三章 树</h2><h3 id="3-1-树与树的表示"><a href="#3-1-树与树的表示" class="headerlink" title="3.1 树与树的表示"></a>3.1 树与树的表示</h3><h4 id="3-1-1-查找"><a href="#3-1-1-查找" class="headerlink" title="3.1.1 查找"></a>3.1.1 查找</h4><p>查找<code>Searching</code>：根据某个给定的关键词K，从集合R中找到关键字与K相同的记录</p>
<p>静态查找：集合中记录是固定的，没有插入和删除操作，只有查找</p>
<p>动态查找：集合中记录是动态变化的；除查找，还可能发生插入和删除</p>
<p><strong>静态查找方法</strong></p>
<ul>
<li><p>方法一：顺序查找$O(n)$</p>
</li>
<li><p>方法二：二分查找$O(log{n})$</p>
<p>假设n个数据元素的关键字满足<strong>有序</strong>，如$k_1&lt;k_2&lt;\cdots&lt;k_n$，并且是连续存放（数组），那么可以进行二分查找</p>
<p>$mid=(left+right)/2$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(List Tbl,ElementType K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left,right,mid,NotFound=<span class="number">-1</span>;</span><br><span class="line">    left=<span class="number">1</span>;</span><br><span class="line">    right=Tbl-&gt;Length;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid=(left&lt;=right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(K&lt;Tbl-&gt;Element[mid])right=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(K&gt;Tbl-&gt;Element[mid])left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/03/qCHwAgDP8dk2YU4.png" alt="image-20211003143047176"></p>
</li>
</ul>
<h4 id="3-1-2-树的基础"><a href="#3-1-2-树的基础" class="headerlink" title="3.1.2 树的基础"></a>3.1.2 树的基础</h4><p>树<code>Tree</code>：$n$个节点构成的有限集合。当$n=0$时，称为空树；对于任一非空树$n&gt;0$，它具备如下特征：</p>
<ul>
<li>树中有一个称为根<code>Root</code>节点的特殊节点，用r表示；</li>
<li>其余节点可以分为$m(m&gt;0)$个互不相交的有限集$T_1,T_2,\dots,T_m$，其中每个集合本身又是一棵树，称为原来树的“子树<code>SubTree</code>”</li>
</ul>
<p><strong>树的一些基本术语</strong></p>
<ol>
<li>结点的度<code>Degree</code>：结点的子树个数</li>
<li>树的度：树的所有节点中最大的度数</li>
<li>叶结点<code>Leaf</code>：度为0的结点</li>
<li>父结点<code>Parent</code>：有子树的结点是其子树的根结点的父结点</li>
<li>子结点<code>Child</code>：若A结点是B结点的父结点，则称B结点是A结点的子结点</li>
<li>兄弟结点<code>Siblings</code>：具有同一父结点的各结点彼此是兄弟结点</li>
<li>路径和路径长度：从结点$n_1$到结点$n_k$的路径为一个结点序列$n_1,n_2,\dots,n_k$，$n_i$是$n_{i+1}$的父结点。路径所包含的边的个数为路径的长度。</li>
<li>祖先结点<code>Ancestor</code>：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。</li>
<li>子孙结点<code>Descendant</code>：某一结点的子树中所有结点是这个结点的子孙。</li>
<li>结点的层次<code>Level</code>：规定根结点在1层，其他任一结点的层数是其父结点的层数加1。</li>
<li>树的深度<code>Depth</code>：树中所有结点中最大层次是这棵树的深度</li>
</ol>
<p><strong>树相关的计算</strong></p>
<p>规律1：（节点个数）m=（边数）n+1<br>规律2： 度为节点的子女个数，可以看作几个出边就是几个度，叶子节点没有度</p>
<p><strong>树的表示</strong></p>
<ul>
<li><p>儿子兄弟表示法</p>
<p><img src="https://i.loli.net/2021/10/03/Cy73TKJzsPctYpg.png" alt="image-20211003153247387"></p>
<p>实际上此方法就构造了一棵新的二叉树，也即实现了二叉树的表示即可表示任意树。</p>
</li>
</ul>
<h3 id="3-2-二叉树及存储结构"><a href="#3-2-二叉树及存储结构" class="headerlink" title="3.2 二叉树及存储结构"></a>3.2 二叉树及存储结构</h3><h4 id="3-2-1-二叉树的定义"><a href="#3-2-1-二叉树的定义" class="headerlink" title="3.2.1 二叉树的定义"></a>3.2.1 二叉树的定义</h4><p>二叉树$T$：一个有穷的结点集合，这个结点可以为空，若不为空，则它是由根结点和称为其左子树$T_L$和右子树$T_R$的两个不相交的二叉树组成。其中每个结点的度最大为2。</p>
<ul>
<li><p>二叉树的子树有左右顺序之分</p>
</li>
<li><p>二叉树的五种基本形态</p>
<p><img src="https://i.loli.net/2021/10/03/5IPq7shkOrE4jA2.png" alt="image-20211003154726945"></p>
</li>
<li><p>特殊二叉树</p>
<ul>
<li><p>斜二叉树<code>Skewed Binary Tree</code></p>
<p><img src="https://i.loli.net/2021/10/03/4eqsA2lmYnydjzO.png" alt="image-20211003154825176"></p>
</li>
<li><p>完全二叉树<code>Complete Binary Tree</code></p>
<p>有n个结点的二叉树，对树中结点按从上至下、从左到右顺序进行编号，编号为$i (1\le i \le n)$结点与满二叉树中编号为i结点在二叉树中位置相同</p>
</li>
<li><p>完美二叉树<code>Perfect Binary Tree</code>、满二叉树<code>Full Binary Tree</code></p>
<p><img src="https://i.loli.net/2021/10/03/v5oWs7NMQcCgDEK.png" alt="image-20211003155852826"></p>
</li>
</ul>
</li>
</ul>
<h4 id="3-2-2-二叉树的几个重要性质"><a href="#3-2-2-二叉树的几个重要性质" class="headerlink" title="3.2.2 二叉树的几个重要性质"></a>3.2.2 二叉树的几个重要性质</h4><ul>
<li><p>一个二叉树第$i$层最大结点数为：$2^{i-1},i\ge 1$</p>
</li>
<li><p>深度为$k$的二叉树有最大结点数为：$2^k-1,k\ge1$</p>
</li>
<li><p>对任何非空二叉树$T$，若$n_0$表示叶结点的个数、$n_2$是度为2的非叶结点的个数，那么两者的关系满足$n_0=n_2+1$</p>
</li>
<li><p>$n$个结点的二叉树一共多少种？</p>
<p>$f(n)=\frac{(2n)!}{n!(n+1)!}$</p>
</li>
<li><p>$n$层二叉树的第$n$层最多有多少个结点？</p>
<p>$f(n)=2^{n-1}$</p>
</li>
<li><p>一个有$n$个结点的完全二叉树的深度为？</p>
<p>$h(n)=log_2n+1$</p>
</li>
<li><p>一个完全二叉树的结点为$n$，则该二叉树的叶子结点为多少？</p>
<p>$f(n)=n-(n/2)$</p>
</li>
</ul>
<h4 id="3-2-3-二叉树的表示和实现"><a href="#3-2-3-二叉树的表示和实现" class="headerlink" title="3.2.3 二叉树的表示和实现"></a>3.2.3 二叉树的表示和实现</h4><p><strong>二叉树的抽象表示</strong></p>
<p><img src="https://i.loli.net/2021/10/03/7Pzga3UrwY2WDjF.png" alt="image-20211003161147938"></p>
<p><strong>二叉树的存储结构</strong></p>
<ol>
<li><p><strong>顺序存储结构</strong></p>
<p>完全二叉树：按从上至下、从左到右顺序存储</p>
<p>$n$个结点的完全二叉树的结点父子关系：</p>
<ul>
<li>非根结点（序号$i&gt;1$）的父结点的序号是$\lfloor i \rfloor$</li>
<li>结点（序号为$i$）的左孩子结点的序号是$2i$（$2i\le n$，否则没有左孩子）</li>
<li>结点（序号为$i$）的右孩子结点的序号是$2i+1$（$2i+1\le n$，否则没有左孩子）</li>
</ul>
<p><img src="https://i.loli.net/2021/10/03/aGwoOLUbhe5Ay1K.png" alt="image-20211003161841643"></p>
<p><img src="https://i.loli.net/2021/10/03/fDRFlQwJt7kTpcy.png" alt="image-20211003161851011"></p>
<p>对于一般的二叉树也可以使用这种结构，但会造成很高的空间浪费</p>
</li>
<li><p><strong>链表存储</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">BinTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/03/6uWiYyUDK7RlFpA.png" alt="image-20211003162138544"></p>
<p><img src="https://i.loli.net/2021/10/03/27Qe9J5phEuKbrI.png" alt="image-20211003162149228"></p>
</li>
<li><p><strong>静态链表</strong></p>
<p>使用结构数组构建“链表形式”的“静态链表”，其中左右孩子指示位存储的是左右孩子所对应的下标</p>
<p><img src="https://i.loli.net/2021/10/03/ST1XvNLK2cOwu3y.png" alt="image-20211003194829854"></p>
</li>
</ol>
<h3 id="3-3-二叉树的遍历"><a href="#3-3-二叉树的遍历" class="headerlink" title="3.3 二叉树的遍历"></a>3.3 二叉树的遍历</h3><p>先序、中序、后序遍历过程中经过节点的路线一样，只是访问各结点的实际不同。</p>
<h4 id="3-3-1-先序遍历"><a href="#3-3-1-先序遍历" class="headerlink" title="3.3.1 先序遍历"></a>3.3.1 先序遍历</h4><p>访问根结点、先序遍历其左子树、先序遍历其右子树</p>
<p><img src="https://i.loli.net/2021/10/03/uLGN2IbQHOPiED5.png" alt="image-20211003182747329"></p>
<p>   <strong>先序遍历非递归遍历</strong>算法：使用<strong>堆栈</strong></p>
<ul>
<li>遇到一个结点，就把它输入然后压栈，并去遍历其左子树</li>
<li>当左子树遍历结束后，按照其右指针再去中序遍历该结点的右子树</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder2</span><span class="params">(BinTree *root)</span>     <span class="comment">//非递归前序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            p=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-中序遍历"><a href="#3-3-2-中序遍历" class="headerlink" title="3.3.2 中序遍历"></a>3.3.2 中序遍历</h4><p>中序遍历其左子树、访问根结点、中序遍历其右子树</p>
<p><img src="https://i.loli.net/2021/10/03/ux5Bjhp9LlSfGac.png" alt="image-20211003182824443"></p>
<p><strong>中序遍历非递归遍历</strong>算法：使用<strong>堆栈</strong></p>
<ul>
<li>遇到一个结点，就把它压栈，并去遍历其左子树</li>
<li>当左子树遍历结束后，从栈顶弹出此结点并访问之</li>
<li>然后按照其右指针再去中序遍历该结点的右子树</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder2</span><span class="params">(BinTree *root)</span>      <span class="comment">//非递归中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            p=s.<span class="built_in">top</span>();</span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-后序遍历"><a href="#3-3-3-后序遍历" class="headerlink" title="3.3.3 后序遍历"></a>3.3.3 后序遍历</h4><p>后序遍历其左子树、后序遍历其右子树、访问根节点</p>
<p><img src="https://i.loli.net/2021/10/03/BoU5hHz8NS6wxRW.png" alt="image-20211003182916552"></p>
<p><strong>后序遍历非递归</strong>遍历算法：使用堆栈</p>
<ul>
<li><p>第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问， 因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就 保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此<em>需要多设置一个变量标识该结点是 否是第一次出现在栈顶</em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder2</span><span class="params">(BinTree *root)</span> <span class="comment">//非递归后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;BTNode*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    BTNode *temp;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>) <span class="comment">//沿左子树一直往下搜索，直至出现没有左子树的结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            BTNode *btn=(BTNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BTNode));</span><br><span class="line">            btn-&gt;btnode=p;</span><br><span class="line">            btn-&gt;isFirst=<span class="literal">true</span>;</span><br><span class="line">            s.<span class="built_in">push</span>(btn);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            temp=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;isFirst==<span class="literal">true</span>) <span class="comment">//表示是第一次出现在栈顶</span></span><br><span class="line">             &#123;</span><br><span class="line">                temp-&gt;isFirst=<span class="literal">false</span>;</span><br><span class="line">                s.<span class="built_in">push</span>(temp);</span><br><span class="line">                p=temp-&gt;btnode-&gt;rchild; <span class="comment">//访问其右子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//第二次出现在栈顶</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;temp-&gt;btnode-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                p=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存 在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了 每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder3</span><span class="params">(BinTree *root)</span> <span class="comment">//非递归后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *cur; <span class="comment">//当前结点</span></span><br><span class="line">    BinTree *pre=<span class="literal">NULL</span>; <span class="comment">//前一次访问的结点</span></span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cur=s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>((cur-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;cur-&gt;rchild==<span class="literal">NULL</span>)||</span><br><span class="line">           (pre!=<span class="literal">NULL</span>&amp;&amp;(pre==cur-&gt;lchild||pre==cur-&gt;rchild)))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;cur-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//如果当前结点没有孩子结点或者孩子节点都已被访问过</span></span><br><span class="line">              s.<span class="built_in">pop</span>();</span><br><span class="line">            pre=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(cur-&gt;rchild);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(cur-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-3-4-层次遍历"><a href="#3-3-4-层次遍历" class="headerlink" title="3.3.4 层次遍历"></a>3.3.4 层次遍历</h4><p>二叉树遍历的核心问题：二维结构的线性化</p>
<ul>
<li>从结点访问其左、右儿子结点</li>
<li>访问左儿子后，右儿子结点需要一个存储结构（堆栈、队列）保存暂时不访问的结点</li>
</ul>
<p><img src="https://i.loli.net/2021/10/03/m4rj3PxYsC5gaek.png" alt="image-20211003192402457"></p>
<p><strong>层序遍历的实现</strong>：利用<strong>队列</strong>，遍历从根节点开始，首先将根结点入队，然后开始执行循环：结点出队、访问该结点、其左右儿子入队</p>
<p><img src="https://i.loli.net/2021/10/03/ke18YHGotfQIrhb.png" alt="image-20211003192702163"></p>
<h4 id="3-3-5-遍历二叉树算法的应用"><a href="#3-3-5-遍历二叉树算法的应用" class="headerlink" title="3.3.5 遍历二叉树算法的应用"></a>3.3.5 遍历二叉树算法的应用</h4><ul>
<li><p>输出二叉树中的叶子结点：在二叉树的遍历算法中增加检测结点“左右子树是否都为空”的判断语句。</p>
</li>
<li><p>求二叉树的高度：二叉树的高度为其左子树和右子树高度最大值+1</p>
<p><img src="https://i.loli.net/2021/10/03/AHuw3xQI4lf6pga.png" alt="image-20211003193034277"></p>
<p><img src="https://i.loli.net/2021/10/03/mrRnDlUBsH4KYAM.png" alt="image-20211003193100014"></p>
</li>
<li><p>二元运算表达式树及其遍历</p>
<p><img src="https://i.loli.net/2021/10/03/jlXLYTpcgxVA1nJ.png" alt="image-20211003193911595"></p>
</li>
<li><p>由两种遍历序列确定二叉树（<strong>必须要有中序序列</strong>）</p>
</li>
<li><p>判别两个二叉树是否同构</p>
<p><img src="https://i.loli.net/2021/10/05/KeXUScZgn3szuQ8.png" alt="image-20211005130722242"></p>
<p><img src="https://i.loli.net/2021/10/05/eNasRGHiCxMf67j.png" alt="image-20211005130750318"></p>
</li>
</ul>
<h3 id="3-4-二叉搜索树"><a href="#3-4-二叉搜索树" class="headerlink" title="3.4 二叉搜索树"></a>3.4 二叉搜索树</h3><h4 id="3-4-1-什么是二叉搜索树"><a href="#3-4-1-什么是二叉搜索树" class="headerlink" title="3.4.1 什么是二叉搜索树"></a>3.4.1 什么是二叉搜索树</h4><p>组织动态查找时，若将数据按照一定的规则在二叉树中进行存储，则每次的搜索的效率取决于树的深度$h(n)=log_2n+1$，即得到一种高效的算法。</p>
<p>二叉搜索树<code>BST,Binary Search Tree</code>，也称二叉排序树或二叉查找树。为一棵非空二叉树，且满足如下三条性质：</p>
<ul>
<li>非空左子树的所有键值小于其根结点的键值；</li>
<li>非空右子树的所有键值大于其根结点的键值；</li>
<li>左、右子树都是二叉搜索树。</li>
</ul>
<h4 id="3-4-2-二叉搜索树的抽象表示和实现"><a href="#3-4-2-二叉搜索树的抽象表示和实现" class="headerlink" title="3.4.2 二叉搜索树的抽象表示和实现"></a>3.4.2 二叉搜索树的抽象表示和实现</h4><p><strong>二叉搜索树的抽象表示</strong></p>
<p><img src="https://i.loli.net/2021/10/05/WGpoKJB1r8Hwtdf.png" alt="image-20211005132237855"></p>
<p><strong>二叉搜索树的查找操作Find</strong></p>
<ul>
<li><p>查找从根结点开始，如果树为空，返回<code>NULL</code></p>
</li>
<li><p>若搜索树非空，则根结点关键字和<code>X</code>进行比较，并进行不同处理：</p>
<ul>
<li>若<code>X</code>小于根结点键值，只需要在左子树中继续搜索</li>
<li>若<code>X</code>大于根结点键值，在右子树中进行继续搜索</li>
<li>若两者比较结果相等，搜索完成，返回指向此节点的指针</li>
</ul>
</li>
<li><p>递归实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(X&gt;BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Find</span>(X,BST-&gt;Right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X&lt;BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Find</span>(X,BST-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>非递归（循环）实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">IterFind</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">if</span>(X&gt;BST-&gt;Data)</span><br><span class="line">            BST=BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X&lt;BST-&gt;Data)</span><br><span class="line">            BST=BST-&gt;Left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>查找最大和最小元素</strong></p>
<ul>
<li><p>最大元素一定在树的最右分枝的端结点上，最小元素一定在树的最左分枝的端结点上</p>
<p><img src="https://i.loli.net/2021/10/05/ueM9ht7maRIDbdz.png" alt="image-20211005133330268"></p>
</li>
<li><p>查找最大/小元素实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(BinTree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Left)</span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FindMin</span>(BST-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(BinTree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right)BST=BST-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>二叉搜索树的插入</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST)&#123;</span><br><span class="line">    	<span class="comment">//若原树为空，生成并返回一个结点的二叉搜索树</span></span><br><span class="line">        BST=<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct TreeNode));</span><br><span class="line">        BST-&gt;Data=X;</span><br><span class="line">        BST-&gt;Left=BST-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(X&lt;BST-&gt;Data) <span class="comment">//递归插入左子树</span></span><br><span class="line">        BST-&gt;Left=<span class="built_in">Insert</span>(X,BST-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X&gt;BST-&gt;Data) <span class="comment">//递归插入右子树</span></span><br><span class="line">        BST-&gt;Right=<span class="built_in">Insert</span>(X,BST-&gt;Right);</span><br><span class="line">    <span class="comment">//X已经存在，查找到原址</span></span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉搜索树的删除</strong></p>
<p>考虑三种情况：</p>
<ul>
<li><p>要删除的是叶结点：直接删除并修改其父节点指针——置为NULL</p>
</li>
<li><p>要删除的节点只有一个孩子结点：将其父结点的指针指向要删除的结点的孩子结点</p>
<p><img src="https://i.loli.net/2021/10/05/b7wca1zp8rB54Ed.png" alt="image-20211005135027150"></p>
</li>
<li><p>要删除的结点有左、右子树：用另一个结点替代被删除节点，通常是左子树的最大元素或右子树的最小元素</p>
<center class="half">
<img src="https://i.loli.net/2021/10/05/wuAUOPrlg7yVZcS.png" alt="image-20211005135557796" style="zoom:50%;" /><img src="https://i.loli.net/2021/10/05/gfwtDoRcKVAY3O7.png" alt="image-20211005135622821" style="zoom:50%;" />
<img src="https://i.loli.net/2021/10/05/NA7QDyCEPqBthLJ.png" alt="image-20211005140009082" style="zoom:50%;" /><img src="C:\Users\Farewellswind\AppData\Roaming\Typora\typora-user-images\image-20211005140052019.png" alt="image-20211005140052019" style="zoom:50%;" />
</center></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    <span class="keyword">if</span>(!BST)<span class="built_in">printf</span>(<span class="string">&quot;Unfindable!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X&lt;BST-&gt;Data)</span><br><span class="line">        BST-&gt;Left=<span class="built_in">Delete</span>(X,BST-&gt;Left); <span class="comment">//左子树递归删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X&gt;BST-&gt;Data)</span><br><span class="line">        BST-&gt;Right=<span class="built_in">Delete</span>(X,BST-&gt;Right); <span class="comment">//右子树递归删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;</span><br><span class="line">        <span class="comment">//找到了被删除节点，且点有左右两个子结点</span></span><br><span class="line">        <span class="comment">//在右子树中找到最小元素</span></span><br><span class="line">        Tmp=<span class="built_in">FindMin</span>(BST-&gt;Right); </span><br><span class="line">        <span class="comment">//将找到的最小值赋值给被删除结点</span></span><br><span class="line">        BST-&gt;Data=Tmp-&gt;Data;</span><br><span class="line">        BST-&gt;Right=<span class="built_in">Delete</span>(BST-&gt;Data,BST-&gt;Right); </span><br><span class="line">        <span class="comment">//在删除节点的右子树中删除最小元素</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//被删除结点有一个或无子结点</span></span><br><span class="line">        Tmp=BST;</span><br><span class="line">        <span class="keyword">if</span>(!BST-&gt;Left) <span class="comment">// 有右孩子或无子结点</span></span><br><span class="line">            BST=BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right) <span class="comment">// 有左孩子或无子结点</span></span><br><span class="line">            BST=BST-&gt;Left;</span><br><span class="line">        <span class="built_in">free</span>(Tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-3-判别是否是同一棵二叉搜索树"><a href="#3-4-3-判别是否是同一棵二叉搜索树" class="headerlink" title="3.4.3 判别是否是同一棵二叉搜索树"></a>3.4.3 判别是否是同一棵二叉搜索树</h4><ul>
<li><p>分别两个输入序列构造两棵二叉搜索树，然后判别是否相同</p>
</li>
<li><p>不建树的判别方法，根据序列，通过定位根节点位置进行判断</p>
<p><img src="https://i.loli.net/2021/10/05/BcZGRdhWjwHyQYN.png" alt="image-20211005152929723"></p>
</li>
<li><p>建一棵树，再判别其他序列是否与该树一致</p>
<ul>
<li><p>搜索树的表示</p>
<p><img src="https://i.loli.net/2021/10/05/N9UovASgp5hBjbM.png" alt="image-20211005153337874"></p>
</li>
<li><p>建搜索树</p>
<p><img src="https://i.loli.net/2021/10/05/cMNbiIVW6yDOhsQ.png" alt="image-20211005153350501"></p>
<p><img src="https://i.loli.net/2021/10/05/xCXqEcDa2nIUzrT.png" alt="image-20211005153424558"></p>
</li>
<li><p>判别一序列是否与搜索树$T$一致</p>
<p><img src="https://i.loli.net/2021/10/05/Pxuh8mvDQSdOrzj.png" alt="image-20211005153500459"></p>
<p><img src="https://i.loli.net/2021/10/05/8JG5IVShalLCWQA.png" alt="image-20211005153526915"></p>
<p><img src="https://i.loli.net/2021/10/05/KBk46Es9yJxVSri.png" alt="image-20211005153537810"></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-5-平衡二叉树"><a href="#3-5-平衡二叉树" class="headerlink" title="3.5 平衡二叉树"></a>3.5 平衡二叉树</h3><h4 id="3-5-1-什么是平衡二叉树"><a href="#3-5-1-什么是平衡二叉树" class="headerlink" title="3.5.1 什么是平衡二叉树"></a>3.5.1 什么是平衡二叉树</h4><p>搜索树结点不同的插入次序，将导致不同的深度和平均查找长度<code>ASL</code>的不同</p>
<p><img src="https://i.loli.net/2021/10/05/A6q7bGdSuYc4gP9.png" alt="image-20211005141319219"></p>
<p>平衡因子<code>Balance Factor(BF)</code>：$BF(T)=h_L-h_R$，其中$h_L$和$h_R$分别为$T$的左子树和右子树的高度</p>
<p>平衡二叉树<code>Balanced Binary Tree</code>/<code>AVL Tree</code>：空树或者任一结点左右子树高度差的绝对值不超过1，即$|BF(T)|\le 1$</p>
<p><img src="https://i.loli.net/2021/10/05/opd5KiryJb3c2C1.png" alt="image-20211005141627202"></p>
<h4 id="3-5-2-平衡二叉树的调整"><a href="#3-5-2-平衡二叉树的调整" class="headerlink" title="3.5.2 平衡二叉树的调整"></a>3.5.2 平衡二叉树的调整</h4><p><img src="https://i.loli.net/2021/10/05/fKX2QoUetuHxi61.gif" alt="right rotate"  /><img src="https://i.loli.net/2021/10/05/ZmF5w6kNKu4fShd.gif" alt="left rotate"  /></p>
<ul>
<li><p>RR旋转：不平衡的“发现者”是A，“麻烦结点”在发现者<strong>右</strong>子树的<strong>右</strong>边，因此成为RR插入，需要RR旋转（右单旋）</p>
<p><img src="https://i.loli.net/2021/10/05/ONnJLiGt9lXsjUv.png" alt="image-20211005143113571"></p>
</li>
<li><p>LL旋转：不平衡的“发现者”是A，“麻烦结点”在发现者<strong>左</strong>子树的<strong>左</strong>边，因此称为LL插入，需要LL旋转（左单旋）</p>
<p><img src="https://i.loli.net/2021/10/05/acBSZzGjt6l7FbH.png" alt="image-20211005143352536"></p>
</li>
<li><p>LR旋转：不平衡的“发现者”是A，“麻烦结点”在<strong>左</strong>子树的<strong>右</strong>边，因此叫做LR插入，需要LR旋转</p>
<p><img src="https://i.loli.net/2021/10/05/LqBR3FzQpHaNPn9.png" alt="image-20211005143920004"></p>
</li>
<li><p>RL旋转：与LR旋转类似</p>
<p><img src="https://i.loli.net/2021/10/05/85soJvICwX4qgEU.png" alt="image-20211005144242923"></p>
</li>
<li><p>PS：有的时候插入元素即使不需要调整结构，也可能需要重新计算平衡因子</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	T key;</span><br><span class="line">	Node&lt;T&gt;* lchild;</span><br><span class="line">	Node&lt;T&gt;* rchild;</span><br><span class="line">	Node&lt;T&gt;(T k) : <span class="built_in">key</span>(k), <span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node&lt;T&gt;* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AVLTree</span>() :<span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">	<span class="function">Node&lt;T&gt;* <span class="title">getRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Node&lt;T&gt;* <span class="title">llRotation</span><span class="params">(Node&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="function">Node&lt;T&gt;* <span class="title">lrRotation</span><span class="params">(Node&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="function">Node&lt;T&gt;* <span class="title">rrRotation</span><span class="params">(Node&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="function">Node&lt;T&gt;* <span class="title">rlRotation</span><span class="params">(Node&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">balance</span><span class="params">(Node&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(Node&lt;T&gt;*, Node&lt;T&gt;*, T)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(Node&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="function">Node&lt;T&gt;* <span class="title">findMin</span><span class="params">(Node&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="function">Node&lt;T&gt;* <span class="title">findMax</span><span class="params">(Node&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fixUp</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Node&lt;T&gt;* <span class="title">find</span><span class="params">(Node&lt;T&gt;* node, T key)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">printTree</span>() &#123;  <span class="comment">//层次遍历</span></span><br><span class="line">	Node&lt;T&gt;* pos = root;  <span class="comment">//当前位置</span></span><br><span class="line">	Node&lt;T&gt;* flag = root;  <span class="comment">//层末标识</span></span><br><span class="line"></span><br><span class="line">	queue&lt;Node&lt;T&gt;*&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);  <span class="comment">//根节点入队</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;  <span class="comment">//队列非空</span></span><br><span class="line">		Node&lt;T&gt;* node = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();  <span class="comment">//弹出队首</span></span><br><span class="line">		cout &lt;&lt; node-&gt;key &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;lchild != <span class="literal">nullptr</span>) &#123;  <span class="comment">//左孩子非空则入队</span></span><br><span class="line">			q.<span class="built_in">push</span>(node-&gt;lchild);</span><br><span class="line">			pos = node-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;rchild != <span class="literal">nullptr</span>) &#123;  <span class="comment">//右孩子非空则入队</span></span><br><span class="line">			q.<span class="built_in">push</span>(node-&gt;rchild);</span><br><span class="line">			pos = node-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (node == flag) &#123;  <span class="comment">//抵达层末</span></span><br><span class="line">			flag = pos;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">insert</span>(<span class="keyword">const</span> T&amp; key) &#123;</span><br><span class="line">	Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;(key);</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		root = node;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node&lt;T&gt;* pos = root;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">//查找插入位置</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;key &lt; pos-&gt;key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pos-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				pos-&gt;lchild = node;</span><br><span class="line">				<span class="built_in">fixUp</span>();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;   <span class="comment">//end if</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				pos = pos-&gt;lchild;</span><br><span class="line">		&#125;  <span class="comment">//end if</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; pos-&gt;key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pos-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				pos-&gt;rchild = node;</span><br><span class="line">				<span class="built_in">fixUp</span>();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;  <span class="comment">//end if</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				pos = pos-&gt;rchild;</span><br><span class="line">		&#125;  <span class="comment">//end if</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span>;  <span class="comment">//树中已有此节点则无操作</span></span><br><span class="line">	&#125;  <span class="comment">//end while</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">getDepth</span>(Node&lt;T&gt;* node) &#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">getDepth</span>(node-&gt;lchild), <span class="built_in">getDepth</span>(node-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">getBalanceFactor</span>(Node&lt;T&gt;* node) &#123;  <span class="comment">//平衡因子 = 左子树高-右子树高</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getDepth</span>(node-&gt;lchild) - <span class="built_in">getDepth</span>(node-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">balance</span>(Node&lt;T&gt;* node) &#123;</span><br><span class="line">	<span class="keyword">int</span> bf = <span class="built_in">getBalanceFactor</span>(node);</span><br><span class="line">	<span class="keyword">if</span> (bf &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getBalanceFactor</span>(node-&gt;lchild) &gt; <span class="number">0</span>)</span><br><span class="line">			root = <span class="built_in">llRotation</span>(node);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			root = <span class="built_in">lrRotation</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (bf &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getBalanceFactor</span>(node-&gt;rchild) &gt; <span class="number">0</span>)</span><br><span class="line">			root = <span class="built_in">rlRotation</span>(node);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			root = <span class="built_in">rrRotation</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LL</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Node&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">llRotation</span>(Node&lt;T&gt;* node) &#123;  <span class="comment">//插入节点在左子树左边，右旋</span></span><br><span class="line">	Node&lt;T&gt;* temp = node-&gt;lchild;</span><br><span class="line">	node-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">	temp-&gt;rchild = node;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LR</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Node&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">lrRotation</span>(Node&lt;T&gt;* node) &#123;  <span class="comment">//插入节点在左子树右边</span></span><br><span class="line">	Node&lt;T&gt;* temp = node-&gt;lchild;</span><br><span class="line">	node-&gt;lchild = <span class="built_in">rrRotation</span>(temp);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">llRotation</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RL</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Node&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">rlRotation</span>(Node&lt;T&gt;* node) &#123;  <span class="comment">//插入节点在右子树左边</span></span><br><span class="line">	Node&lt;T&gt;* temp = node-&gt;rchild;</span><br><span class="line">	node-&gt;rchild = <span class="built_in">llRotation</span>(temp);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">rrRotation</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RR</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Node&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">rrRotation</span>(Node&lt;T&gt;* node) &#123;  <span class="comment">//插入节点在右子树右边，左旋</span></span><br><span class="line">	Node&lt;T&gt;* temp = node-&gt;rchild;</span><br><span class="line">	node-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">	temp-&gt;lchild = node;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> AVLTree&lt;T&gt;::<span class="built_in">remove</span>(Node&lt;T&gt;* node, Node&lt;T&gt;* parent, T key) &#123;</span><br><span class="line">	Node&lt;T&gt;* temp = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)  <span class="comment">// 未找到目标节点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">remove</span>(node-&gt;lchild, node, key);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">remove</span>(node-&gt;rchild, node, key);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;lchild &amp;&amp; node-&gt;rchild) &#123;  <span class="comment">//删除节点有左子树也有右子树</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getDepth</span>(node-&gt;lchild) &gt; <span class="built_in">getDepth</span>(node-&gt;rchild)) &#123;  <span class="comment">//左子树高，前驱替代</span></span><br><span class="line">			temp = <span class="built_in">findMax</span>(node-&gt;lchild);</span><br><span class="line">			node-&gt;key = temp-&gt;key;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">remove</span>(node-&gt;lchild,node, node-&gt;key);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;  <span class="comment">//右子树不比左子树矮，后驱替代</span></span><br><span class="line">			temp = <span class="built_in">findMin</span>(node-&gt;rchild);</span><br><span class="line">			node-&gt;key = temp-&gt;key;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">remove</span>(node-&gt;rchild, node, node-&gt;key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ((node-&gt;lchild &amp;&amp; node-&gt;rchild == <span class="literal">nullptr</span>)) &#123;  <span class="comment">//删除节点有左孩子无右孩子</span></span><br><span class="line">			temp = <span class="built_in">findMax</span>(node-&gt;lchild);</span><br><span class="line">			node-&gt;key = temp-&gt;key;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">remove</span>(node-&gt;lchild, node, node-&gt;key);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;rchild &amp;&amp; node-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">//删除节点有右孩子无左孩子</span></span><br><span class="line">			temp = <span class="built_in">findMin</span>(node-&gt;rchild);</span><br><span class="line">			node-&gt;key = temp-&gt;key;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">remove</span>(node-&gt;rchild, node, node-&gt;key);</span><br><span class="line">		&#125;  <span class="comment">//end if</span></span><br><span class="line">		<span class="keyword">else</span> &#123;  <span class="comment">//删除节点最终递归到删除叶子节点</span></span><br><span class="line">			<span class="keyword">if</span> (node == parent-&gt;lchild)  <span class="comment">//父节点指针置空</span></span><br><span class="line">				parent-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				parent-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">delete</span> node;  <span class="comment">//释放子节点</span></span><br><span class="line">			node = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">fixUp</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  <span class="comment">//end else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">fixUp</span>() &#123;</span><br><span class="line">	Node&lt;T&gt;* temp = <span class="keyword">this</span>-&gt;root;  <span class="comment">//自顶向下调整树</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)  <span class="comment">//寻找失衡的节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getBalanceFactor</span>(temp) == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="built_in">getBalanceFactor</span>(temp-&gt;lchild)) == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				temp = temp-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">getBalanceFactor</span>(temp) == <span class="number">-2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="built_in">getBalanceFactor</span>(temp-&gt;rchild)) == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				temp = temp-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">balance</span>(temp);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Node&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">find</span>(Node&lt;T&gt;* node, T key) &#123;</span><br><span class="line">	<span class="keyword">while</span> (node != <span class="literal">nullptr</span> &amp;&amp; key != node-&gt;key) &#123;  <span class="comment">//迭代查找</span></span><br><span class="line">		<span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">			node = node-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			node = node-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Element &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; doesn&#x27;t exist!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Element &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; exists.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Node&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">findMax</span>(Node&lt;T&gt;* node) &#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (node-&gt;rchild)</span><br><span class="line">			node = node-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Node&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">findMin</span>(Node&lt;T&gt;* node) &#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;lchild == <span class="literal">nullptr</span>)  <span class="comment">//左孩子为空，当前节点已是最左下</span></span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">findMin</span>(node-&gt;lchild);  <span class="comment">//左孩子不为空，往左子树遍历</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">//空树返回nullptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[]&#123; <span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>&#125;;<span class="comment">//ll:738512建树;rr:7385129删除2;rl:7385124删除4;lr:748516建树</span></span><br><span class="line">	AVLTree&lt;<span class="keyword">int</span>&gt; avl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		avl.<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	avl.<span class="built_in">printTree</span>();</span><br><span class="line">	avl.<span class="built_in">find</span>(avl.<span class="built_in">getRoot</span>(),<span class="number">8</span>);</span><br><span class="line">	avl.<span class="built_in">remove</span>(avl.<span class="built_in">getRoot</span>(), <span class="literal">nullptr</span>, <span class="number">8</span>);</span><br><span class="line">	avl.<span class="built_in">printTree</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kite97/p/13431904.html">Above Code from [kite97]</a></p>
<h3 id="3-6-堆"><a href="#3-6-堆" class="headerlink" title="3.6 堆"></a>3.6 堆</h3><h4 id="3-6-1-什么是堆"><a href="#3-6-1-什么是堆" class="headerlink" title="3.6.1 什么是堆"></a>3.6.1 什么是堆</h4><p>优先队列<code>Priority Queue</code>：特殊的队列，取出元素的顺序是按照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。</p>
<p>堆<code>Heap</code>即为优先队列的完全二叉树表示，堆的两个特性：</p>
<ul>
<li>结构性：用数组表示的<strong>完全二叉树</strong>；</li>
<li>有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）<ul>
<li>最大堆<code>MaxHeap</code>也称“大顶堆”：最大值</li>
<li>最小堆<code>MinHeap</code>也称“小顶堆”：最小值</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/CkGU6YNpHtmF5BO.png" alt="image-20211005194016661"></p>
<h4 id="3-6-2-堆的表示和实现"><a href="#3-6-2-堆的表示和实现" class="headerlink" title="3.6.2 堆的表示和实现"></a>3.6.2 堆的表示和实现</h4><p><strong>堆抽象数据结构描述</strong></p>
<p><img src="https://i.loli.net/2021/10/05/sgDbZMKTGiHnUrp.png" alt="image-20211005194052919"></p>
<p><strong>最大堆的操作：创建、插入、删除、维护</strong></p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> *<span class="title">Heap</span>;</span> <span class="comment">/* 堆的类型定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> &#123;</span></span><br><span class="line">    ElementType *Data; <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    <span class="keyword">int</span> Size;          <span class="comment">/* 堆中当前元素个数 */</span></span><br><span class="line">    <span class="keyword">int</span> Capacity;      <span class="comment">/* 堆的最大容量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Heap MaxHeap; <span class="comment">/* 最大堆 */</span></span><br><span class="line"><span class="keyword">typedef</span> Heap MinHeap; <span class="comment">/* 最小堆 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATA 1000  <span class="comment">/* 该值应根据具体情况定义为大于堆中所有可能元素的值 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MaxHeap <span class="title">CreateHeap</span><span class="params">( <span class="keyword">int</span> MaxSize )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 创建容量为MaxSize的空的最大堆 */</span></span><br><span class="line"></span><br><span class="line">    MaxHeap H = (MaxHeap)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct HNode));</span><br><span class="line">    H-&gt;Data = (ElementType *)<span class="built_in">malloc</span>((MaxSize+<span class="number">1</span>)*<span class="built_in"><span class="keyword">sizeof</span></span>(ElementType));</span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Data[<span class="number">0</span>] = MAXDATA; <span class="comment">/* 定义&quot;哨兵&quot;为大于堆中所有可能元素的值*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>插入</p>
<p>通过一个示例来理解堆插入的过程，将<code>16</code>插入到下面的堆中</p>
<center class="half">
<img src="https://upload-images.jianshu.io/upload_images/4064751-51fd43a2d2191488.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp" alt="img" style="zoom:80%;" />
<img src="https://upload-images.jianshu.io/upload_images/4064751-7dd89da71927acb8.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp" alt="img" style="zoom:80%;" />
<img src="https://upload-images.jianshu.io/upload_images/4064751-785a7a6cd104f775.png?imageMogr2/auto-orient/strip|imageView2/2/w/204/format/webp" alt="img" style="zoom:80%;" />
<img src="https://upload-images.jianshu.io/upload_images/4064751-d7dae273e1f5a0ba.png?imageMogr2/auto-orient/strip|imageView2/2/w/192/format/webp" alt="img" style="zoom:80%;" />
</center>
  `16` 被添加最后一行的第一个空位。不行的是，现在堆属性不满足，因为 `2` 在 `16` 的上面，我们需要将大的数字在上面（这是一个最大堆）为了恢复堆属性，我们需要交换 `16` 和 `2`。现在还没有完成，因为 `10` 也比 `16` 小。我们继续交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。这就是所谓的 **shift-up**，每一次插入操作后都需要进行。它将一个太大或者太小的数字“浮起”到树的顶部。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">( MaxHeap H )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == H-&gt;Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将新增结点插入到从其父结点到根节点的有序序列中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( MaxHeap H, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">IsFull</span>(H) ) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size; <span class="comment">/* i指向插入后堆中的最后一个元素的位置 */</span></span><br><span class="line">    <span class="comment">//哨兵起到一个边界判定的作用，若是没有在data[0]设置哨兵元素则判定条件应为 H-&gt;Data[i/2] &lt; X &amp;&amp; i&gt;1</span></span><br><span class="line">    <span class="keyword">for</span> ( ; H-&gt;Data[i/<span class="number">2</span>] &lt; X; i/=<span class="number">2</span> ) <span class="comment">//当父结点小于当前结点时进行交换</span></span><br><span class="line">        H-&gt;Data[i] = H-&gt;Data[i/<span class="number">2</span>]; <span class="comment">/* 上滤X */</span></span><br><span class="line">    H-&gt;Data[i] = X; <span class="comment">/* 将X插入 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>删除</p>
<center class="half">
<img src="https://upload-images.jianshu.io/upload_images/4064751-7eb32c6486a44f73.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp" alt="img" style="zoom:75%;" />
<img src="https://upload-images.jianshu.io/upload_images/4064751-71783aa7bd24a51f.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp" alt="img" style="zoom:75%;" />
<img src="https://upload-images.jianshu.io/upload_images/4064751-c28b15dc371b8e97.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp" alt="img" style="zoom:75%;" />
<img src="https://upload-images.jianshu.io/upload_images/4064751-bfc42e89b5411f9b.png?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp" alt="img" style="zoom:75%;" />
<img src="https://upload-images.jianshu.io/upload_images/4064751-8b04275965f88961.png?imageMogr2/auto-orient/strip|imageView2/2/w/208/format/webp" alt="img" style="zoom:75%;" />
</center>

<p>我们将这个树中的 <code>10</code> 删除，但在删除后顶部空出了一个节点，很自然的我们要从下面找到合适的结点来维持堆的属性。</p>
<p>当插入节点的时候，我们将新的值返给数组的尾部。现在我们来做相反的事情：我们取出数组中的最后一个元素，将它放到树的顶部，然后再修复堆属性。</p>
<p>现在来看怎么 <strong>shift-down</strong>。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。现在有两个数字可用于交换 <code>7</code> 和 <code>2</code>。我们选择这两者中的较大者称为最大值放在树的顶部，所以交换 <code>7</code> 和 <code>1</code>。</p>
<p>继续堆化直到该节点没有任何子节点或者它比两个子节点都要大为止。对于我们的堆，我们只需要再有一次交换就恢复了堆属性。</p>
<p>实质的核心思想就是：已知左子树是一个堆，右子树也是一个堆，对于一个新的元素，要如何将其调整为一个堆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1 <span class="comment">/* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">( MaxHeap H )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">( MaxHeap H )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 从最大堆H中取出键值为最大的元素，并删除一个结点 */</span></span><br><span class="line">    <span class="keyword">int</span> Parent, Child;</span><br><span class="line">    ElementType MaxItem, X;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">IsEmpty</span>(H) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxItem = H-&gt;Data[<span class="number">1</span>]; <span class="comment">/* 取出根结点存放的最大值 */</span></span><br><span class="line">    <span class="comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span></span><br><span class="line">    X = H-&gt;Data[H-&gt;Size--]; <span class="comment">/* 取最后一个结点，且注意当前堆的规模要减小 */</span></span><br><span class="line">    <span class="comment">//将最后一个元素假定为最大值，之后找出其左右儿子中较大的那个替换位置</span></span><br><span class="line">    <span class="comment">//之后重复操作到找不到左右儿子，则此时堆的顺序维护完成</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( Parent=<span class="number">1</span>; Parent*<span class="number">2</span>&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * <span class="number">2</span>; <span class="comment">//Child先指向左儿子</span></span><br><span class="line">        <span class="keyword">if</span>( (Child!=H-&gt;Size) <span class="comment">//child!=H-&gt;Size意味着一定存在右儿子</span></span><br><span class="line">           &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="number">1</span>]) )</span><br><span class="line">            Child++;  <span class="comment">/* Child指向左右子结点的较大者 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="keyword">break</span>; <span class="comment">/* 找到了合适位置 */</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">/* 下滤X */</span></span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxItem;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>给定n个元素进行创建</p>
<ul>
<li>方法一：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为$O(Nlog{N})$</li>
<li>方法二：在线性时间复杂度下建立最大堆。<ul>
<li>将N个元素按照输入顺序存入，先满足完全二叉树的结构特性；</li>
<li>调整各结点位置，以满足最大堆的有序特性。调整堆时采用删除操作中的方法进行调整，但从下往上进行调整，满足左右子树为堆+1结点的条件。故从最后一个非叶子节点也即最后一个父结点进行调整。</li>
</ul>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------- 建造最大堆 -----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">( MaxHeap H, <span class="keyword">int</span> p )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */</span></span><br><span class="line">    <span class="keyword">int</span> Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line"></span><br><span class="line">    X = H-&gt;Data[p]; <span class="comment">/* 取出根结点存放的值 */</span></span><br><span class="line">    <span class="keyword">for</span>( Parent=p; Parent*<span class="number">2</span>&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="number">1</span>]) )</span><br><span class="line">            Child++;  <span class="comment">/* Child指向左右子结点的较大者 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="keyword">break</span>; <span class="comment">/* 找到了合适位置 */</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">/* 下滤X */</span></span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">( MaxHeap H )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  */</span></span><br><span class="line">  <span class="comment">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 从最后一个结点的父节点（也即最后一个非叶子结点）开始，到根结点1 */</span></span><br><span class="line">    <span class="keyword">for</span>( i = H-&gt;Size/<span class="number">2</span>; i&gt;<span class="number">0</span>; i-- )</span><br><span class="line">        <span class="built_in">PercDown</span>( H, i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-7-哈夫曼树和哈夫曼编码"><a href="#3-7-哈夫曼树和哈夫曼编码" class="headerlink" title="3.7 哈夫曼树和哈夫曼编码"></a>3.7 哈夫曼树和哈夫曼编码</h3><h4 id="3-7-1-什么是哈夫曼树"><a href="#3-7-1-什么是哈夫曼树" class="headerlink" title="3.7.1 什么是哈夫曼树"></a>3.7.1 什么是哈夫曼树</h4><p>带权路径长度<code>WPL</code>：设二叉树有n个叶子结点，每个叶子结点带有权值$W_k$，从根结点到每个叶子结点的长度为$l_k$，则每个叶子结点的带权路径长度之和就是：$WPL=\sum^n_{k=1}w_kl_k$</p>
<p>最优二叉树/哈夫曼树：WPL最小的二叉树</p>
<h4 id="3-7-2-哈夫曼树的构造"><a href="#3-7-2-哈夫曼树的构造" class="headerlink" title="3.7.2 哈夫曼树的构造"></a>3.7.2 哈夫曼树的构造</h4><p>每次把权值最小的两棵二叉树合并（利用构造最小堆可以很好地实现）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Weight;</span><br><span class="line">    HuffmanTree Left,Right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HuffmanTree <span class="title">Huffman</span><span class="params">(MinHeap H)</span></span>&#123;</span><br><span class="line">    <span class="comment">//假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    <span class="built_in">BuildMinHeap</span>(H); <span class="comment">//将H-&gt;Elements[]按照权值调整为最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;H-&gt;Size;i++)&#123; <span class="comment">//做H-&gt;Size-1次合并</span></span><br><span class="line">        T=<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct TreeNode));</span><br><span class="line">        T-&gt;Left=<span class="built_in">DeleteMin</span>(H);</span><br><span class="line">        T-&gt;Right=<span class="built_in">DeleteMin</span>(H); <span class="comment">//从最小堆中取出两个最小的节点作为左右节点</span></span><br><span class="line">        T-&gt;Weight=T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight; <span class="comment">//重新计算权值</span></span><br><span class="line">        <span class="built_in">Insert</span>(H,T); <span class="comment">//将新的T插入到最小堆中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-3-哈夫曼树的特点"><a href="#3-7-3-哈夫曼树的特点" class="headerlink" title="3.7.3 哈夫曼树的特点"></a>3.7.3 哈夫曼树的特点</h4><ul>
<li>没有度为1的结点</li>
<li>n个叶子结点的哈夫曼树共有2n-1个结点</li>
<li>哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树</li>
<li>对同一组权值${w_1,w_2,\dots,w_n}$，存在不同构的哈夫曼树，但WPL值是一样的</li>
</ul>
<h4 id="3-7-4-哈夫曼编码"><a href="#3-7-4-哈夫曼编码" class="headerlink" title="3.7.4 哈夫曼编码"></a>3.7.4 哈夫曼编码</h4><p>给定一段字符串，使用哈夫曼编码进行编码（不等长编码）可以使得该字符串的编码存储空间最小</p>
<p>在不等长编码中，为避免二义性，需要满足前缀码<code>prefix code</code>要求（任何字符的编码都不是另一字符编码的前缀），用二叉树表示编码即可完美避免二义性</p>
<h3 id="3-8-集合及运算"><a href="#3-8-集合及运算" class="headerlink" title="3.8 集合及运算"></a>3.8 集合及运算</h3><h4 id="3-8-1-集合的表示"><a href="#3-8-1-集合的表示" class="headerlink" title="3.8.1 集合的表示"></a>3.8.1 集合的表示</h4><ul>
<li><p>集合运算：交、并、补、差，判定一个元素是否属于某一集合</p>
</li>
<li><p>并查集：集合并、查某元素属于什么集合</p>
</li>
<li><p>并查集问题中使用树的结构存储集合，树的每一个结点代表一个集合元素</p>
<p><img src="https://i.loli.net/2021/10/05/6sCTXAVmzJc9Wvg.png" alt="image-20211005211118299"></p>
</li>
</ul>
<h4 id="3-8-2-并查集的实现"><a href="#3-8-2-并查集的实现" class="headerlink" title="3.8.2 并查集的实现"></a>3.8.2 并查集的实现</h4><ul>
<li><p>采用数组存储形式</p>
<p><img src="https://i.loli.net/2021/10/05/AETuNp6BUaklXHJ.png" alt="image-20211005211442798"></p>
</li>
<li><p>查找某个元素所在的集合（用根结点表示）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000                  <span class="comment">/* 集合最大元素个数 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;           <span class="comment">/* 默认元素可以用非负整数表示 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SetName;               <span class="comment">/* 默认用根结点的下标作为集合名称 */</span></span><br><span class="line"><span class="keyword">typedef</span> ElementType SetType[MAXN]; <span class="comment">/* 假设集合元素下标从0开始 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">SetName <span class="title">Find</span><span class="params">( SetType S, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 默认集合元素全部初始化为-1 */</span></span><br><span class="line">    <span class="keyword">if</span> ( S[X] &lt; <span class="number">0</span> ) <span class="comment">/* 找到集合的根 */</span></span><br><span class="line">        <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> S[X] = <span class="built_in">Find</span>( S, S[X] ); <span class="comment">/* 路径压缩 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(SetType S[],ElementType X)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在数组S中查找值为X的元素所对应的集合</span></span><br><span class="line">    <span class="comment">//MaxSize是全局变量，为数组S的最大长度</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MaxSize &amp;&amp; S[i].Data!=X;i++);</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=MaxSize)<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//未找到X，返回-1</span></span><br><span class="line">    <span class="keyword">for</span>(;S[i].Parent&gt;=<span class="number">0</span>;i=S[i].Parent);</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">//找到x所属集合，返回树根结点在数组S中的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>集合的并运算</p>
<ul>
<li>分别找到X1和X2两个元素所在的集合树的根结点</li>
<li>如果他们不同根，则将其中一个根节点的父结点指针设置为另一个根结点的数组下标</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[],ElementType X1,ElementType X2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Root1,Root2;</span><br><span class="line">    Root1=<span class="built_in">Find</span>(S,X1);</span><br><span class="line">    Root2=<span class="built_in">Find</span>(S,X2);</span><br><span class="line">    <span class="keyword">if</span>(Root1!=Root2)S[Root2].Parent=Root1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种固定将root2挂在root1下的方式会导致树的深度越来越深，影响find的效率</span></span><br><span class="line"><span class="comment">//于是通过负数判定是否为根结点，而负数的绝对值则表示节点的个数，通过简单的修改，在判断时对两个集合的个数进行修改即可更具效率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">( SetType S, SetName Root1, SetName Root2 )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 这里默认Root1和Root2是不同集合的根结点 */</span></span><br><span class="line">    <span class="comment">/* 保证小集合并入大集合 */</span></span><br><span class="line">    <span class="keyword">if</span> ( S[Root2] &lt; S[Root1] ) &#123; <span class="comment">/* 如果集合2比较大 */</span></span><br><span class="line">        S[Root2] += S[Root1];     <span class="comment">/* 集合1并入集合2  */</span></span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">/* 如果集合1比较大 */</span></span><br><span class="line">        S[Root1] += S[Root2];     <span class="comment">/* 集合2并入集合1  */</span></span><br><span class="line">        S[Root2] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第四章-图"><a href="#第四章-图" class="headerlink" title="第四章 图"></a>第四章 图</h2><h3 id="3-1-什么是图"><a href="#3-1-什么是图" class="headerlink" title="3.1 什么是图"></a>3.1 什么是图</h3><p>图<code>Graph</code>表示多对多的关系，包含一组顶点（通常用$V(Vertex)$）表示顶点集合，一组边（通常用$E(Edge)$）表示边的集合：</p>
<ul>
<li>边是顶点对：$(v,w)\in E$，其中$v,w\in V$</li>
<li>有向边$&lt;v,w&gt;$表示从$v$指向$w$的边（单向）</li>
<li>不考虑重边和自回路</li>
</ul>
<p><strong>抽象数据类型定义</strong></p>
<p><img src="https://i.loli.net/2021/10/06/UhvN78oTbS3OncG.png" alt="image-20211006100951316"></p>
<p><strong>图的表示</strong></p>
<ul>
<li><p>邻接矩阵$G[N][N]$，$N$个定点从0到$N-1$的编号<br>$$<br>G[i][j]=\left{<br>\begin{aligned}<br>1 &amp;&amp; 若&lt;v_i,v_j&gt;是G中的边 \<br>0 &amp;&amp; 否则<br>\end{aligned}<br>\right.<br>$$<br><img src="https://i.loli.net/2021/10/06/6MAHl5WPEkhK1Lt.png" alt="image-20211006101530542"></p>
<p>对于无向图，可以使用一个长度为$N(N+1)/2$的一维数组$A$存储${G_{00},G_{10},G_{11},\dots,G_{n-1 \ 0},\dots,G_{n-1 \ n-1}}$，则$G_{ij}$在$A$中而对应的下标是$(i*(i+1)/2+j)$</p>
<p>邻接矩阵的优点：</p>
<ul>
<li>简单直观好理解</li>
<li>方便检查任意一队顶点间是否存在边</li>
<li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</li>
<li>方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数为“入度”）。无向图的度为对应行/列的非零元素个数；有向图对应行非零元素个数为出度，对应列非零元素个数为入度</li>
</ul>
<p>邻接矩阵的缺点：</p>
<ul>
<li>浪费空间：对于稀疏图（点很多，边很少）有大量无效元素，而对于稠密图（特别是完全图）还是很合算的</li>
<li>浪费时间：统计稀疏图一共有多少条边</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 图的邻接矩阵表示法 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100    <span class="comment">/* 最大顶点数设为100 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535        <span class="comment">/* ∞设为双字节无符号整数的最大值65535*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;         <span class="comment">/* 用顶点下标表示顶点,为整型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> WeightType;        <span class="comment">/* 边的权值设为整型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;        <span class="comment">/* 顶点存储的数据类型设为字符型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 边的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span></span><br><span class="line">    Vertex V1, V2;      <span class="comment">/* 有向边&lt;V1, V2&gt; */</span></span><br><span class="line">    WeightType Weight;  <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line">       </span><br><span class="line"><span class="comment">/* 图结点的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;  <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne;  <span class="comment">/* 边数   */</span></span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum]; <span class="comment">/* 邻接矩阵 */</span></span><br><span class="line">    DataType Data[MaxVertexNum];      <span class="comment">/* 存顶点的数据 */</span></span><br><span class="line">    <span class="comment">/* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph; <span class="comment">/* 以邻接矩阵存储的图类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">( <span class="keyword">int</span> VertexNum )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始化一个有VertexNum个顶点但没有边的图 */</span></span><br><span class="line">    Vertex V, W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    </span><br><span class="line">    Graph = (MGraph)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct GNode)); <span class="comment">/* 建立图 */</span></span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 初始化邻接矩阵 */</span></span><br><span class="line">    <span class="comment">/* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span></span><br><span class="line">    <span class="keyword">for</span> (V=<span class="number">0</span>; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        <span class="keyword">for</span> (W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++)  </span><br><span class="line">            Graph-&gt;G[V][W] = INFINITY;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> Graph; </span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">( MGraph Graph, Edge E )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/* 插入边 &lt;V1, V2&gt; */</span></span><br><span class="line">     Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;    </span><br><span class="line">     <span class="comment">/* 若是无向图，还要插入边&lt;V2, V1&gt; */</span></span><br><span class="line">     Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="keyword">int</span> Nv, i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Nv);   <span class="comment">/* 读入顶点个数 */</span></span><br><span class="line">    Graph = <span class="built_in">CreateGraph</span>(Nv); <span class="comment">/* 初始化有Nv个顶点但没有边的图 */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));   <span class="comment">/* 读入边数 */</span></span><br><span class="line">    <span class="keyword">if</span> ( Graph-&gt;Ne != <span class="number">0</span> ) &#123; <span class="comment">/* 如果有边 */</span> </span><br><span class="line">        E = (Edge)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct ENode)); <span class="comment">/* 建立边结点 */</span> </span><br><span class="line">        <span class="comment">/* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Graph-&gt;Ne; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); </span><br><span class="line">            <span class="comment">/* 注意：如果权重不是整型，Weight的读入格式要改 */</span></span><br><span class="line">            <span class="built_in">InsertEdge</span>( Graph, E );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果顶点有数据的话，读入数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (V=<span class="number">0</span>; V&lt;Graph-&gt;Nv; V++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;(Graph-&gt;Data[V]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>邻接表：$G[N]$为指针数组，对应矩阵每行一个链表，只存非零元素</p>
<p><img src="https://i.loli.net/2021/10/06/eMtvDYJ4ymHg2dA.png" alt="image-20211006102551238"></p>
<p>邻接表优点：</p>
<ul>
<li>方便找任一顶点的所有邻接点</li>
<li>节约稀疏图的空间：需要N个头指针+2E个结点（每个指针至少两个域）</li>
<li>对于无向图方便计算任一顶点的度；而对于有向图则只能计算出度，需要构造逆邻接表来方便计算出度</li>
</ul>
<p>邻接表缺点：不方便检查任意一对顶点间是否存在边</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 图的邻接表表示法 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100    <span class="comment">/* 最大顶点数设为100 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;         <span class="comment">/* 用顶点下标表示顶点,为整型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> WeightType;        <span class="comment">/* 边的权值设为整型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;        <span class="comment">/* 顶点存储的数据类型设为字符型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 边的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span></span><br><span class="line">    Vertex V1, V2;      <span class="comment">/* 有向边&lt;V1, V2&gt; */</span></span><br><span class="line">    WeightType Weight;  <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接点的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span> *<span class="title">PtrToAdjVNode</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span>&#123;</span></span><br><span class="line">    Vertex AdjV;        <span class="comment">/* 邻接点下标 */</span></span><br><span class="line">    WeightType Weight;  <span class="comment">/* 边权重 */</span></span><br><span class="line">    PtrToAdjVNode Next;    <span class="comment">/* 指向下一个邻接点的指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顶点表头结点的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span>&#123;</span></span><br><span class="line">    PtrToAdjVNode FirstEdge;<span class="comment">/* 边表头指针 */</span></span><br><span class="line">    DataType Data;            <span class="comment">/* 存顶点的数据 */</span></span><br><span class="line">    <span class="comment">/* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */</span></span><br><span class="line">&#125; AdjList[MaxVertexNum];    <span class="comment">/* AdjList是邻接表类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图结点的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> Nv;     <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne;     <span class="comment">/* 边数   */</span></span><br><span class="line">    AdjList G;  <span class="comment">/* 邻接表 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode LGraph; <span class="comment">/* 以邻接表方式存储的图类型 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LGraph <span class="title">CreateGraph</span><span class="params">( <span class="keyword">int</span> VertexNum )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始化一个有VertexNum个顶点但没有边的图 */</span></span><br><span class="line">    Vertex V;</span><br><span class="line">    LGraph Graph;</span><br><span class="line">    </span><br><span class="line">    Graph = (LGraph)<span class="built_in">malloc</span>( <span class="built_in"><span class="keyword">sizeof</span></span>(struct GNode) ); <span class="comment">/* 建立图 */</span></span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 初始化邻接表头指针 */</span></span><br><span class="line">    <span class="comment">/* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span></span><br><span class="line">       <span class="keyword">for</span> (V=<span class="number">0</span>; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        Graph-&gt;G[V].FirstEdge = <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> Graph; </span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">( LGraph Graph, Edge E )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PtrToAdjVNode NewNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 插入边 &lt;V1, V2&gt; */</span></span><br><span class="line">    <span class="comment">/* 为V2建立新的邻接点 */</span></span><br><span class="line">    NewNode = (PtrToAdjVNode)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct AdjVNode));</span><br><span class="line">    NewNode-&gt;AdjV = E-&gt;V2;</span><br><span class="line">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line">    <span class="comment">/* 将V2插入V1的表头 */</span></span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 若是无向图，还要插入边 &lt;V2, V1&gt; */</span></span><br><span class="line">    <span class="comment">/* 为V1建立新的邻接点 */</span></span><br><span class="line">    NewNode = (PtrToAdjVNode)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct AdjVNode));</span><br><span class="line">    NewNode-&gt;AdjV = E-&gt;V1;</span><br><span class="line">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line">    <span class="comment">/* 将V1插入V2的表头 */</span></span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LGraph <span class="title">BuildGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="keyword">int</span> Nv, i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Nv);   <span class="comment">/* 读入顶点个数 */</span></span><br><span class="line">    Graph = <span class="built_in">CreateGraph</span>(Nv); <span class="comment">/* 初始化有Nv个顶点但没有边的图 */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));   <span class="comment">/* 读入边数 */</span></span><br><span class="line">    <span class="keyword">if</span> ( Graph-&gt;Ne != <span class="number">0</span> ) &#123; <span class="comment">/* 如果有边 */</span> </span><br><span class="line">        E = (Edge)<span class="built_in">malloc</span>( <span class="built_in"><span class="keyword">sizeof</span></span>(struct ENode) ); <span class="comment">/* 建立边结点 */</span> </span><br><span class="line">        <span class="comment">/* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Graph-&gt;Ne; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); </span><br><span class="line">            <span class="comment">/* 注意：如果权重不是整型，Weight的读入格式要改 */</span></span><br><span class="line">            <span class="built_in">InsertEdge</span>( Graph, E );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果顶点有数据的话，读入数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (V=<span class="number">0</span>; V&lt;Graph-&gt;Nv; V++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;(Graph-&gt;G[V].Data));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
<h3 id="3-2-图的遍历"><a href="#3-2-图的遍历" class="headerlink" title="3.2 图的遍历"></a>3.2 图的遍历</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构, 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/18/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/" rel="prev" title="激活函数">
      <i class="fa fa-chevron-left"></i> 激活函数
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/" rel="next" title="机器学习相关名词解释">
      机器学习相关名词解释 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88ZJU-MOOC%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">数据结构（ZJU-MOOC）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">第一讲 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 什么是数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 什么是算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 应用实例：最大子列和问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">第二讲 线性结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 线性表及其实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1 多项式的表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2.1.2 线性表的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">2.1.3 广义表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%A0%86%E6%A0%88"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 堆栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E6%A0%88"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 什么是堆栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%A0%86%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2 堆栈的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2.2.3 表达式求值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%98%9F%E5%88%97"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">2.3.1 什么是队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2.3.2 队列的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%91"><span class="nav-number">1.3.</span> <span class="nav-text">第三章 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%A0%91%E4%B8%8E%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 树与树的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E6%9F%A5%E6%89%BE"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">3.1.1 查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">3.1.2 树的基础</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 二叉树及存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">3.2.1 二叉树的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%80%A7%E8%B4%A8"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">3.2.2 二叉树的几个重要性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3.2.3 二叉树的表示和实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.3.1 先序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.3.2 中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3.3.3 后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">3.3.4 层次遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">3.3.5 遍历二叉树算法的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">3.4.1 什么是二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">3.4.2 二叉搜索树的抽象表示和实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E5%88%A4%E5%88%AB%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">3.4.3 判别是否是同一棵二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5 平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">3.5.1 什么是平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B0%83%E6%95%B4"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">3.5.2 平衡二叉树的调整</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%A0%86"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">3.6.1 什么是堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-%E5%A0%86%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">3.6.2 堆的表示和实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">1.3.7.</span> <span class="nav-text">3.7 哈夫曼树和哈夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">3.7.1 什么是哈夫曼树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-2-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">3.7.2 哈夫曼树的构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-3-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">3.7.3 哈夫曼树的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-4-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">3.7.4 哈夫曼编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97"><span class="nav-number">1.3.8.</span> <span class="nav-text">3.8 集合及运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-1-%E9%9B%86%E5%90%88%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">3.8.1 集合的表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-2-%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">3.8.2 并查集的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9B%BE"><span class="nav-number">1.4.</span> <span class="nav-text">第四章 图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.1 什么是图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">3.2 图的遍历</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Farewellswind</p>
  <div class="site-description" itemprop="description">Blog to record sth. powered by GitPages & Hexo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Farewellswind</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
